package emu.jectrex.cpu;

import emu.jectrex.BaseChip;

/**
 * A cycle-by-cycle based emulation of the MC6809.
 * 
 * Although it looks somewhat insane that there is a method in this class that has
 * nearly 13000 lines of code, don't worry, it wasn't written by hand. The code in
 * emulateCycle was generated by using as input the 6809cyc.txt file created by Arto
 * Salmi, and the cycle-by-cycle flow charts in the MC6809 datasheet for reference 
 * and clarification whilst writing the code generating algorithm.
 * 
 * In addition to this, many of the methods from the M6809 class in the Java Emulation
 * Framework (JEF) (written by Sun-Cheung Wong and Erik Duijs) have been used as the
 * basis of the code that performs the actual execution of the instructions, in fact
 * this class began life as an attempt to convert their excellent 6809 emulation into
 * a cycle-based implementation. The end result looks almost completely different when
 * compared with their class, but I am very grateful to them that their work gave me a
 * solid head start. 
 * 
 * I am also indebted to SÃ¸ren Roug whose set of Java unit tests for the MC6809 (part
 * of this osnine-java project) I made use of to test several of the instructions.
 * 
 * @author Lance Ewing
 */
public class Cpu6809 extends BaseChip {

  // Hardware RESET and interrupts are modelled as special instructions
  // with an associated sequence of steps.
  private static final int FIRQ_INSTRUCTION  = 0x1300;
  private static final int IRQ_INSTRUCTION   = 0x1301;
  private static final int NMI_INSTRUCTION   = 0x1302;
  private static final int RESET_INSTRUCTION = 0x1303;
  
  // An initial unassigned value for the instructionRegister.
  private static final int NO_INSTRUCTION    = 0xFFFF;
  
  // IRQ Vector Table.
  private static final int RESET_VECTOR_HI = 0xfffe;
  private static final int RESET_VECTOR_LO = 0xffff;
  private static final int NMI_VECTOR_HI   = 0xfffc;
  private static final int NMI_VECTOR_LO   = 0xfffd;
  private static final int SWI_VECTOR_HI   = 0xfffa;
  private static final int SWI_VECTOR_LO   = 0xfffb;
  private static final int IRQ_VECTOR_HI   = 0xfff8;
  private static final int IRQ_VECTOR_LO   = 0xfff9;
  private static final int FIRQ_VECTOR_HI  = 0xfff6;
  private static final int FIRQ_VECTOR_LO  = 0xfff7;
  private static final int SWI2_VECTOR_HI  = 0xfff4;
  private static final int SWI2_VECTOR_LO  = 0xfff5;
  private static final int SWI3_VECTOR_HI  = 0xfff2;
  private static final int SWI3_VECTOR_LO  = 0xfff3;
  
  // IRQ signals.
  private static final int S_NONE = 0;
  private static final int S_NMI  = 1;
  private static final int S_IRQ  = 2;
  private static final int S_FIRQ = 4;
  
  // Condition Code Register constants.
  private static final int C_MASK = 0x0001;
  private static final int V_MASK = 0x0002;
  private static final int Z_MASK = 0x0004;
  private static final int N_MASK = 0x0008;
  private static final int I_MASK = 0x0010;
  private static final int H_MASK = 0x0020;
  private static final int F_MASK = 0x0040;
  private static final int E_MASK = 0x0080;

  // The individual Condition Code Register flag values.
  private boolean entireFlag;
  private boolean firqDisableFlag;
  private boolean halfCarryFlag;
  private boolean irqDisableFlag;
  private boolean negativeFlag;
  private boolean zeroFlag;
  private boolean overflowFlag;
  private boolean carryFlag;

  // The core CPU state registers.
  private int accumulatorA;
  private int accumulatorB;
  private int directPageRegister;
  private int stackPointer;
  private int userStackPointer;
  private int indexRegisterX;
  private int indexRegisterY;
  
  /**
   * Points to the address of the next instruction to be executed.
   */
  protected int programCounter;
  
  /**
   * Holds the op code of the instruction currently being executed. Some op codes
   * are "fake" op codes that the emulator uses for efficiency reasons, e.g. the
   * indexed address mode op codes, interrupt and reset op codes.
   */
  protected int instructionRegister = NO_INSTRUCTION;

  /**
   * The current cycle of the current instruction being executed.
   */
  protected int instructionCycleNum;
  
  /**
   * Input data latch. When operand data is fetched, it comes in through here.
   */
  private int inputDataLatch;

  /**
   * Data bus buffer. Holds outbound data.
   */
  private int dataBusBuffer;

  /**
   * Holds the combined effective address value.
   */
  private int effectiveAddress;

  /**
   * Holds the low byte of the effective address.
   */
  private int effectiveAddressLow;

  /**
   * Holds the high byte of the effective address.
   */
  private int effectiveAddressHigh;
  
  /**
   * The current state of the interrupt pins.
   */
  private int interruptStatus;
  
  /**
   * NMI is not enabled until the first time stack pointer is set.
   */
  private boolean nmiArmed;
  
  /**
   * Has a hardware RESET been triggered.
   */
  private boolean reset;

  /**
   * When an instruction involves calculating an offset, then this variable is used.
   */
  private int offset;

  // Variables used by CWAI.
  private int ccMask = 0;
  private int vectorAddressHi = 0;
  private int vectorAddressLo = 0;
  
  // Used by a set of instruction steps needs to be executed in the middle of another 
  // set. This is usually for the Indexed Mode.
  private int savedInstruction;
  private int savedCycle;
  
  /**
   * Represents the register that is being used when in INDEXED address mode.
   */
  private int indexedAddressModeRegister;
  
  /**
   * Stores the Post Byte for those instructions that use one.
   */
  private int postByte;

  /**
   * Constructor for Cpu6809SingleCycle.
   */
  public Cpu6809() {
    reset();
  }

  /**
   * Resets the CPU.
   */
  public void reset() {
    // Set the internal state to its initial state.
    directPageRegister = 0;
    setCC(0);
    irqDisableFlag = true;
    firqDisableFlag = true;
    interruptStatus = S_NONE;
    
    // NMI is not acknowledged until the program loads the stack pointer for the first time.
    nmiArmed = false;
    
    effectiveAddress = 0;
    effectiveAddressHigh = 0;
    effectiveAddressLow = 0;
    
    // Prepare for execution of the RESET hardware instruction steps.
    reset = true;
    instructionRegister = RESET_INSTRUCTION;
    instructionCycleNum = 0;
  }

  /**
   * Emulates the given number of machine cycles.
   * 
   * @param numOfCycles The number of cycles to execute.
   */
  public void emulateCycles(int numOfCycles) {
    for (int i=0; i<numOfCycles; i++) {
      emulateCycle();
    }
  }
  
  /**
   * Emulates a machine cycle. There should be exactly one read or one write per
   * cycle, even in scenarios where the fetched data is discarded.
   */
  public void emulateCycle() {
    // Switch on the current instruction.
    switch (instructionRegister) {

    // START OF GENERATED CODE

      // NEG DIRECT
      case 0: {
        // | 00 0000 | NEG | DIRECT | 6 | 2 | uaaaa |
        // | Negate | d=-d
        // | neg -- - - -- - - 60 6 2 70 6 3 -- - - m=-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            dataBusBuffer = neg(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 5:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [1] ILLEGAL
      case 1:
        illegal();
        break;

      // [2] ILLEGAL
      case 2:
        illegal();
        break;

      // COM DIRECT
      case 3: {
        // | 03 0003 | COM | DIRECT | 6 | 2 | -aa01 |
        // | Complement | d=~d
        // | com -- - - -- - - 63 6 2 73 6 3 -- - - m=~m - - x x 0 1
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            dataBusBuffer = com(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 5:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LSR DIRECT
      case 4: {
        // | 04 0004 | LSR | DIRECT | 6 | 2 | -0a-s |
        // | Logical Shift Right | d=->{C,d,0}
        // | lsr -- - - -- - - 64 6 2 74 6 3 -- - - (u)m>>=1 - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            dataBusBuffer = lsr(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 5:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [5] ILLEGAL
      case 5:
        illegal();
        break;

      // ROR DIRECT
      case 6: {
        // | 06 0006 | ROR | DIRECT | 6 | 2 | -aa-s |
        // | Rotate Right | d=->{C,d}
        // | ror -- - - -- - - 66 6 2 76 6 3 -- - - m=ror(m) - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            dataBusBuffer = ror(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 5:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ASR DIRECT
      case 7: {
        // | 07 0007 | ASR | DIRECT | 6 | 2 | uaa-s |
        // | Arithmetic Shift Right | d=d/2
        // | asr -- - - -- - - 67 6 2 77 6 3 -- - - (i)m>>=1 - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            dataBusBuffer = asr(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 5:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ASL DIRECT
      case 8: {
        // | 08 0008 | LSL/ASL | DIRECT | 6 | 2 | naaas |
        // | Arithmetic Shift Left | d=d*2
        // | asl -- - - -- - - 68 6 2 78 6 3 -- - - m<<=1 - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            dataBusBuffer = asl(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 5:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ROL DIRECT
      case 9: {
        // | 09 0009 | ROL | DIRECT | 6 | 2 | -aaas |
        // | Rotate Left | d={C,d}<-
        // | rol -- - - -- - - 69 6 2 79 6 3 -- - - m=rol(m) - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            dataBusBuffer = rol(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 5:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // DEC DIRECT
      case 10: {
        // | 0A 0010 | DEC | DIRECT | 6 | 2 | -aaa- |
        // | Decrement | d=d-1
        // | dec -- - - -- - - 6a 6 2 7a 6 3 -- - - m-=1 - - x x x -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            dataBusBuffer = dec(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 5:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [11] ILLEGAL
      case 11:
        illegal();
        break;

      // INC DIRECT
      case 12: {
        // | 0C 0012 | INC | DIRECT | 6 | 2 | -aaa- |
        // | Increment | d=d+1
        // | inc -- - - -- - - 6c 6 2 7c 6 3 -- - - m+=1 - - x x x -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            dataBusBuffer = inc(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 5:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // TST DIRECT
      case 13: {
        // | 0D 0013 | TST | DIRECT | 6 | 2 | -aa0- |
        // | Test | s
        // | tst -- - - -- - - 6d 4 2 7d 4 3 -- - - m-0 - - x x 0 0
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            tst(inputDataLatch);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // JMP DIRECT
      case 14: {
        // | 0E 0014 | JMP | DIRECT | 3 | 2 | ----- |
        // | Jump | PC=EAs
        // | jmp -- - - 0e 3 2 6e 3 2 7e 3 3 -- - - jmp - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CLR DIRECT
      case 15: {
        // | 0F 0015 | CLR | DIRECT | 6 | 2 | -0100 |
        // | Clear | d=0
        // | clr -- - - -- - - 6f 5 2 7f 5 3 -- - - m=0 - - x x 0 0
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            dataBusBuffer = clr();
            break;

          // WRITE_DATA_EA
          case 5:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // PAGE1 VARIANT
      case 16: {
        // | 10 0016 | PAGE1 | VARIANT | 1 | 1 | +++++ |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC (EXECUTE)
          case 1:
            instructionRegister = (instructionRegister << 8) | fetch(programCounter++);
            break;

        }
        break;
      }

      // PAGE2 VARIANT
      case 17: {
        // | 11 0017 | PAGE2 | VARIANT | 1 | 1 | +++++ |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC (EXECUTE)
          case 1:
            instructionRegister = (instructionRegister << 8) | fetch(programCounter++);
            break;

        }
        break;
      }

      // NOP INHERENT
      case 18: {
        // | 12 0018 | NOP | INHERENT | 2 | 1 | ----- |
        // | No Operation |
        // | nop -- - - -- - - -- - - -- - - 01 1 1 nop - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SYNC INHERENT
      case 19: {
        // | 13 0019 | SYNC | INHERENT | 2 | 1 | ----- |
        // | Sync. to interrupt | (min ~s=2)
        // | sync -- - - -- - - -- - - -- - - 13 ? 1 sync to int - - - - - -
        switch (instructionCycleNum++) {
          // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC
          case 1:
            fetch(programCounter);
            break;

          // DO

          // FETCH_IGNORE_Z (HIGH IMPEDANCE)
          case 2:

            // WHILE_INTERRUPT_NOT_PRESENT
            
            if (!(((interruptStatus & S_NMI) != 0) || ((interruptStatus & S_FIRQ) != 0) || ((interruptStatus & S_IRQ) != 0))) {
              // No interrupt. Decrement by 1 so that we stay in this wait state.
              instructionCycleNum = instructionCycleNum - 1;
            }
            break;

          // FETCH_IGNORE_Z (EXECUTE)
          case 3:
            // Do nothing.
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [20] ILLEGAL
      case 20:
        illegal();
        break;

      // [21] ILLEGAL
      case 21:
        illegal();
        break;

      // LBRA RELATIVE
      case 22: {
        // | 16 0022 | LBRA | RELATIVE | 5 | 3 | ----- |
        // | Long Branch Always | PC=nn
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_HIGH_PC
          case 1:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 2:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 3:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            programCounter = effectiveAddress;
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBSR RELATIVE
      case 23: {
        // | 17 0023 | LBSR | RELATIVE | 9 | 3 | ----- |
        // | Long Branch Subroutine | -[S]=PC,LBRA
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_HIGH_PC
          case 1:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 2:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            break;

          // FETCH_IGNORE_FFFF
          case 4:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_EA
          case 5:
            fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF
          case 6:
            fetch(0xffff);
            break;

          // WRITE_RETURN_ADDR_LOW_SP
          case 7:
            write(--stackPointer, (programCounter & 0xff));
            break;

          // WRITE_RETURN_ADDR_HIGH_SP (EXECUTE)
          case 8:
            write(--stackPointer, (programCounter >> 8) & 0xff);
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [24] ILLEGAL
      case 24:
        illegal();
        break;

      // DAA INHERENT
      case 25: {
        // | 19 0025 | DAA | INHERENT | 2 | 1 | -aa0a |
        // | Decimal Adjust Acc. | A=BCD format
        // | daa -- - - -- - - -- - - -- - - 19 2 1 a=da(a) - - x x x 3
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorA = daa(accumulatorA);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ORCC IMMEDIATE
      case 26: {
        // | 1A 0026 | ORCC | IMMEDIATE | 3 | 2 | ddddd |
        // | Inclusive OR CCR | CC=CCvn
        // | orcc 1a 3 2 -- - - -- - - -- - - -- - - cc|=im 6 6 6 6 6 6
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC
          case 1:
            inputDataLatch = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 2:
            fetch(0xffff);
            setCC(getCC() | inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [27] ILLEGAL
      case 27:
        illegal();
        break;

      // ANDCC IMMEDIATE
      case 28: {
        // | 1C 0028 | ANDCC | IMMEDIATE | 3 | 2 | ddddd |
        // | Logical AND with CCR | CC=CC&s
        // | andcc 1c 3 2 -- - - -- - - -- - - -- - - cc&=im 6 6 6 6 6 6
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC
          case 1:
            inputDataLatch = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 2:
            fetch(0xffff);
            setCC(getCC() & inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SEX INHERENT
      case 29: {
        // | 1D 0029 | SEX | INHERENT | 2 | 1 | -aa0- |
        // | Sign Extend | D=B
        // | sex -- - - -- - - -- - - -- - - 1d 2 1 d=(sc)b - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            setD(sex(accumulatorB));
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // EXG IMMEDIATE
      case 30: {
        // | 1E 0030 | EXG | INHERENT | 8 | 2 | ccccc |
        // | Exchange (r1 size=r2) | r1<->r2
        // | exg 1e 8 2 -- - - -- - - -- - - -- - - r(n)<->r(n) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 4:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 5:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 6:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 7:
            fetch(0xffff);
            exg(postByte);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // TFR IMMEDIATE
      case 31: {
        // | 1F 0031 | TFR | INHERENT | 7 | 2 | ccccc |
        // | Transfer (r1 size<=r2) | r2=r1
        // | tfr 1f 6 2 -- - - -- - - -- - - -- - - r(n)=r(n) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 4:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            tfr(postByte);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BRA RELATIVE
      case 32: {
        // | 20 0032 | BRA | RELATIVE | 3 | 2 | ----- |
        // | Branch Always | PC=m
        // | bra 20 3 2 -- - - -- - - -- - - -- - - bra - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BRN RELATIVE
      case 33: {
        // | 21 0033 | BRN | RELATIVE | 3 | 2 | ----- |
        // | Branch Never | NOP
        // | brn 21 3 2 -- - - -- - - -- - - -- - - bra( 0) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BHI RELATIVE
      case 34: {
        // | 22 0034 | BHI | RELATIVE | 3 | 2 | ----- |
        // | Branch if Higher | If CvZ=0
        // | bhi 22 3 2 -- - - -- - - -- - - -- - - bra(hi) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (!(carryFlag || zeroFlag))
              programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BLS RELATIVE
      case 35: {
        // | 23 0035 | BLS | RELATIVE | 3 | 2 | ----- |
        // | Branch if Lower/Same | If CvZ=1
        // | bls 23 3 2 -- - - -- - - -- - - -- - - bra(ls) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (carryFlag || zeroFlag)
              programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BCC RELATIVE
      case 36: {
        // | 24 0036 | BHS/BCC | RELATIVE | 3 | 2 | ----- |
        // | Branch if Carry Clear | If C=0
        // | bcc 24 3 2 -- - - -- - - -- - - -- - - bra(cc) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (!carryFlag)
              programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BCS RELATIVE
      case 37: {
        // | 25 0037 | BLO/BCS | RELATIVE | 3 | 2 | ----- |
        // | Branch if Carry Set | If C=1
        // | bcs 25 3 2 -- - - -- - - -- - - -- - - bra(cs) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (carryFlag)
              programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BNE RELATIVE
      case 38: {
        // | 26 0038 | BNE | RELATIVE | 3 | 2 | ----- |
        // | Branch if Not Equal | If Z=0
        // | bne 26 3 2 -- - - -- - - -- - - -- - - bra(ne) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (!zeroFlag)
              programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BEQ RELATIVE
      case 39: {
        // | 27 0039 | BEQ | RELATIVE | 3 | 2 | ----- |
        // | Branch if Equal | If Z=1
        // | beq 27 3 2 -- - - -- - - -- - - -- - - bra(eq) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (zeroFlag)
              programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BVC RELATIVE
      case 40: {
        // | 28 0040 | BVC | RELATIVE | 3 | 2 | ----- |
        // | Branch if Overflow Clr | If V=0
        // | bvc 28 3 2 -- - - -- - - -- - - -- - - bra(vc) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (!overflowFlag)
              programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BVS RELATIVE
      case 41: {
        // | 29 0041 | BVS | RELATIVE | 3 | 2 | ----- |
        // | Branch if Overflow Set | If V=1
        // | bvs 29 3 2 -- - - -- - - -- - - -- - - bra(vs) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (overflowFlag)
              programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BPL RELATIVE
      case 42: {
        // | 2A 0042 | BPL | RELATIVE | 3 | 2 | ----- |
        // | Branch if Plus | If N=0
        // | bpl 2a 3 2 -- - - -- - - -- - - -- - - bra(pl) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (!negativeFlag)
              programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BMI RELATIVE
      case 43: {
        // | 2B 0043 | BMI | RELATIVE | 3 | 2 | ----- |
        // | Branch if Minus | If N=1
        // | bmi 2b 3 2 -- - - -- - - -- - - -- - - bra(mi) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (negativeFlag)
              programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BGE RELATIVE
      case 44: {
        // | 2C 0044 | BGE | RELATIVE | 3 | 2 | ----- |
        // | Branch if Great/Equal | If NxV=0
        // | bge 2c 3 2 -- - - -- - - -- - - -- - - bra(ge) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (!(negativeFlag ^ overflowFlag))
              programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BLT RELATIVE
      case 45: {
        // | 2D 0045 | BLT | RELATIVE | 3 | 2 | ----- |
        // | Branch if Less Than | If NxV=1
        // | blt 2d 3 2 -- - - -- - - -- - - -- - - bra(lt) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (negativeFlag ^ overflowFlag)
              programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BGT RELATIVE
      case 46: {
        // | 2E 0046 | BGT | RELATIVE | 3 | 2 | ----- |
        // | Branch if Greater Than | If Zv{NxV}=0
        // | bgt 2e 3 2 -- - - -- - - -- - - -- - - bra(gt) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (!(zeroFlag || (negativeFlag ^ overflowFlag)))
              programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BLE RELATIVE
      case 47: {
        // | 2F 0047 | BLE | RELATIVE | 3 | 2 | ----- |
        // | Branch if Less/Equal | If Zv{NxV}=1
        // | ble 2f 3 2 -- - - -- - - -- - - -- - - bra(le) - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (zeroFlag || (negativeFlag ^ overflowFlag))
              programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LEAX INDEXED
      case 48: {
        // | 30 0048 | LEAX | INDEXED | 4 | 2 | --a-- |
        // | leax -- - - -- - - 30 4 2 -- - - -- - - s=&m - - - x - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 2:
            fetch(0xffff);
            indexRegisterX = effectiveAddress;
            zeroFlag = (indexRegisterX == 0);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LEAY INDEXED
      case 49: {
        // | 31 0049 | LEAY | INDEXED | 4 | 2 | --a-- |
        // | leay -- - - -- - - 31 4 2 -- - - -- - - s=&m - - - x - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 2:
            fetch(0xffff);
            indexRegisterY = effectiveAddress;
            zeroFlag = (indexRegisterY == 0);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LEAS INDEXED
      case 50: {
        // | 32 0050 | LEAS | INDEXED | 4 | 2 | ----- |
        // | leas -- - - -- - - 32 4 2 -- - - -- - - s=&m - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 2:
            fetch(0xffff);
            stackPointer = effectiveAddress;
            nmiArmed = true;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LEAU INDEXED
      case 51: {
        // | 33 0051 | LEAU | INDEXED | 4 | 2 | ----- |
        // | leau -- - - -- - - 33 4 2 -- - - -- - - s=&m - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 2:
            fetch(0xffff);
            userStackPointer = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // PSHS IMMEDIATE
      case 52: {
        // | 34 0052 | PSHS | INHERENT | 5 | 2 | ----- |
        // | Push reg(s) (not S) | -[S]={r,...}
        // | pshs 34 ? 2 -- - - -- - - -- - - -- - - push rf - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_SP
          case 4:
            fetch(stackPointer);
            break;

          // WRITE_PC_LOW_SP_
          case 5:
            if ((postByte & 0x80) != 0) {
              write(--stackPointer, (programCounter & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_PC_HIGH_SP_
          case 6:
            if ((postByte & 0x80) != 0) {
              write(--stackPointer, (programCounter >> 8) & 0xff);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_USER_STACK_LOW_SP_
          case 7:
            if ((postByte & 0x40) != 0) {
              write(--stackPointer, (userStackPointer & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_USER_STACK_HIGH_SP_
          case 8:
            if ((postByte & 0x40) != 0) {
              write(--stackPointer, (userStackPointer >> 8) & 0xff);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_Y_REGISTER_LOW_SP_
          case 9:
            if ((postByte & 0x20) != 0) {
              write(--stackPointer, (indexRegisterY & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_Y_REGISTER_HIGH_SP_
          case 10:
            if ((postByte & 0x20) != 0) {
              write(--stackPointer, (indexRegisterY >> 8) & 0xff);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_X_REGISTER_LOW_SP_
          case 11:
            if ((postByte & 0x10) != 0) {
              write(--stackPointer, (indexRegisterX & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_X_REGISTER_HIGH_SP_
          case 12:
            if ((postByte & 0x10) != 0) {
              write(--stackPointer, (indexRegisterX >> 8) & 0xff);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_DP_REGISTER_SP_
          case 13:
            if ((postByte & 0x08) != 0) {
              write(--stackPointer, (directPageRegister & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_B_REGISTER_SP_
          case 14:
            if ((postByte & 0x04) != 0) {
              write(--stackPointer, (accumulatorB & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_A_REGISTER_SP_
          case 15:
            if ((postByte & 0x02) != 0) {
              write(--stackPointer, (accumulatorA & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_CC_REGISTER_SP_ (EXECUTE)
          case 16:
            if ((postByte & 0x01) != 0) {
              write(--stackPointer, (getCC() & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // PULS IMMEDIATE
      case 53: {
        // | 35 0053 | PULS | INHERENT | 5 | 2 | ccccc |
        // | Pull reg(s) (not S) | {r,...}=[S]+
        // | puls 35 ? 2 -- - - -- - - -- - - -- - - pull rf - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // FETCH_CC_REGISTER_SP_
          case 4:
            if ((postByte & 0x01) != 0) {
              setCC(fetch(stackPointer++));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_A_REGISTER_SP_
          case 5:
            if ((postByte & 0x02) != 0) {
              accumulatorA = fetch(stackPointer++);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_B_REGISTER_SP_
          case 6:
            if ((postByte & 0x04) != 0) {
              accumulatorB = fetch(stackPointer++);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_DP_REGISTER_SP_
          case 7:
            if ((postByte & 0x08) != 0) {
              directPageRegister = fetch(stackPointer++);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_X_REGISTER_HIGH_SP_
          case 8:
            if ((postByte & 0x10) != 0) {
              indexRegisterX = (fetch(stackPointer++) << 8);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_X_REGISTER_LOW_SP_
          case 9:
            if ((postByte & 0x10) != 0) {
              indexRegisterX = indexRegisterX | fetch(stackPointer++);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_Y_REGISTER_HIGH_SP_
          case 10:
            if ((postByte & 0x20) != 0) {
              indexRegisterY = (fetch(stackPointer++) << 8);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_Y_REGISTER_LOW_SP_
          case 11:
            if ((postByte & 0x20) != 0) {
              indexRegisterY = indexRegisterY | fetch(stackPointer++);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_USER_STACK_HIGH_SP_
          case 12:
            if ((postByte & 0x40) != 0) {
              userStackPointer = (fetch(stackPointer++) << 8);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_USER_STACK_LOW_SP_
          case 13:
            if ((postByte & 0x40) != 0) {
              userStackPointer = userStackPointer | fetch(stackPointer++);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_PC_HIGH_SP_
          case 14:
            if ((postByte & 0x80) != 0) {
              programCounter = (fetch(stackPointer++) << 8);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_PC_LOW_SP_
          case 15:
            if ((postByte & 0x80) != 0) {
              programCounter = programCounter | fetch(stackPointer++);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_IGNORE_SP (EXECUTE)
          case 16:
            fetch(stackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // PSHU IMMEDIATE
      case 54: {
        // | 36 0054 | PSHU | INHERENT | 5 | 2 | ----- |
        // | Push reg(s) (not U) | -[U]={r,...}
        // | pshu 36 ? 2 -- - - -- - - -- - - -- - - push rf - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_US
          case 4:
            fetch(userStackPointer);
            break;

          // WRITE_PC_LOW_US_
          case 5:
            if ((postByte & 0x80) != 0) {
              write(--userStackPointer, (programCounter & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_PC_HIGH_US_
          case 6:
            if ((postByte & 0x80) != 0) {
              write(--userStackPointer, (programCounter >> 8) & 0xff);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_STACK_LOW_US_
          case 7:
            if ((postByte & 0x40) != 0) {
              write(--userStackPointer, (stackPointer & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_STACK_HIGH_US_
          case 8:
            if ((postByte & 0x40) != 0) {
              write(--userStackPointer, (stackPointer >> 8) & 0xff);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_Y_REGISTER_LOW_US_
          case 9:
            if ((postByte & 0x20) != 0) {
              write(--userStackPointer, (indexRegisterY & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_Y_REGISTER_HIGH_US_
          case 10:
            if ((postByte & 0x20) != 0) {
              write(--userStackPointer, (indexRegisterY >> 8) & 0xff);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_X_REGISTER_LOW_US_
          case 11:
            if ((postByte & 0x10) != 0) {
              write(--userStackPointer, (indexRegisterX & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_X_REGISTER_HIGH_US_
          case 12:
            if ((postByte & 0x10) != 0) {
              write(--userStackPointer, (indexRegisterX >> 8) & 0xff);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_DP_REGISTER_US_
          case 13:
            if ((postByte & 0x08) != 0) {
              write(--userStackPointer, (directPageRegister & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_B_REGISTER_US_
          case 14:
            if ((postByte & 0x04) != 0) {
              write(--userStackPointer, (accumulatorB & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_A_REGISTER_US_
          case 15:
            if ((postByte & 0x02) != 0) {
              write(--userStackPointer, (accumulatorA & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // WRITE_CC_REGISTER_US_ (EXECUTE)
          case 16:
            if ((postByte & 0x01) != 0) {
              write(--userStackPointer, (getCC() & 0xff));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // PULU IMMEDIATE
      case 55: {
        // | 37 0055 | PULU | INHERENT | 5 | 2 | ccccc |
        // | Pull reg(s) (not U) | {r,...}=[U]+
        // | pulu 37 ? 2 -- - - -- - - -- - - -- - - pull rf - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // FETCH_CC_REGISTER_US_
          case 4:
            if ((postByte & 0x01) != 0) {
              setCC(fetch(userStackPointer++));
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_A_REGISTER_US_
          case 5:
            if ((postByte & 0x02) != 0) {
              accumulatorA = fetch(userStackPointer++);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_B_REGISTER_US_
          case 6:
            if ((postByte & 0x04) != 0) {
              accumulatorB = fetch(userStackPointer++);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_DP_REGISTER_US_
          case 7:
            if ((postByte & 0x08) != 0) {
              directPageRegister = fetch(userStackPointer++);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_X_REGISTER_HIGH_US_
          case 8:
            if ((postByte & 0x10) != 0) {
              indexRegisterX = (fetch(userStackPointer++) << 8);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_X_REGISTER_LOW_US_
          case 9:
            if ((postByte & 0x10) != 0) {
              indexRegisterX = indexRegisterX | fetch(userStackPointer++);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_Y_REGISTER_HIGH_US_
          case 10:
            if ((postByte & 0x20) != 0) {
              indexRegisterY = (fetch(userStackPointer++) << 8);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_Y_REGISTER_LOW_US_
          case 11:
            if ((postByte & 0x20) != 0) {
              indexRegisterY = indexRegisterY | fetch(userStackPointer++);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_STACK_HIGH_US_
          case 12:
            if ((postByte & 0x40) != 0) {
              stackPointer = (fetch(userStackPointer++) << 8);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_STACK_LOW_US_
          case 13:
            if ((postByte & 0x40) != 0) {
              stackPointer = stackPointer | fetch(userStackPointer++);
              nmiArmed = true;
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_PC_HIGH_US_
          case 14:
            if ((postByte & 0x80) != 0) {
              programCounter = (fetch(userStackPointer++) << 8);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_PC_LOW_US_
          case 15:
            if ((postByte & 0x80) != 0) {
              programCounter = programCounter | fetch(userStackPointer++);
              break;
            }
            else {
              instructionCycleNum++;
            }

          // FETCH_IGNORE_US (EXECUTE)
          case 16:
            fetch(userStackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [56] ILLEGAL
      case 56:
        illegal();
        break;

      // RTS INHERENT
      case 57: {
        // | 39 0057 | RTS | INHERENT | 5 | 1 | ----- |
        // | Return from Subroutine | PC=[S]+
        // | rts -- - - -- - - -- - - -- - - 39 5 1 rts - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC
          case 1:
            fetch(programCounter);
            break;

          // FETCH_PC_HIGH_SP
          case 2:
            programCounter = (fetch(stackPointer++) << 8);
            break;

          // FETCH_PC_LOW_SP
          case 3:
            programCounter = programCounter | fetch(stackPointer++);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ABX INHERENT
      case 58: {
        // | 3A 0058 | ABX | INHERENT | 3 | 1 | ----- |
        // | Add to Index Register | X=X+B
        // | abx -- - - -- - - -- - - -- - - 3a 1 1 x+=(uc)b - - - - - -
        switch (instructionCycleNum++) {
          // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous instruction.

          // FETCH_IGNORE_PC
          case 1:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 2:
            fetch(0xffff);
            indexRegisterX = (indexRegisterX + accumulatorB) & 0xffff;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // RTI INHERENT
      case 59: {
        // | 3B 0059 | RTI | INHERENT | 6/15 | 1 | ----- |
        // | Return from Interrupt | {regs}=[S]+
        // | rti -- - - -- - - -- - - -- - - 3b a 1 rti x x x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC
          case 1:
            fetch(programCounter);
            break;

          // FETCH_CCR_CHECK_E_FLAG_SP
          case 2:
            setCC(fetch(stackPointer++));
            if (!entireFlag)
              instructionCycleNum = 12;
            break;

          // FETCH_A_REGISTER_SP
          case 3:
            accumulatorA = fetch(stackPointer++);
            break;

          // FETCH_B_REGISTER_SP
          case 4:
            accumulatorB = fetch(stackPointer++);
            break;

          // FETCH_DP_REGISTER_SP
          case 5:
            directPageRegister = fetch(stackPointer++);
            break;

          // FETCH_X_REGISTER_HIGH_SP
          case 6:
            indexRegisterX = (fetch(stackPointer++) << 8);
            break;

          // FETCH_X_REGISTER_LOW_SP
          case 7:
            indexRegisterX = indexRegisterX | fetch(stackPointer++);
            break;

          // FETCH_Y_REGISTER_HIGH_SP
          case 8:
            indexRegisterY = (fetch(stackPointer++) << 8);
            break;

          // FETCH_Y_REGISTER_LOW_SP
          case 9:
            indexRegisterY = indexRegisterY | fetch(stackPointer++);
            break;

          // FETCH_USER_STACK_HIGH_SP
          case 10:
            userStackPointer = (fetch(stackPointer++) << 8);
            break;

          // FETCH_USER_STACK_LOW_SP
          case 11:
            userStackPointer = userStackPointer | fetch(stackPointer++);
            break;

          // FETCH_PC_HIGH_SP
          case 12:
            programCounter = (fetch(stackPointer++) << 8);
            break;

          // FETCH_PC_LOW_SP
          case 13:
            programCounter = programCounter | fetch(stackPointer++);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 14:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CWAI INHERENT
      case 60: {
        // | 3C 0060 | CWAI | INHERENT | 21 | 2 | ddddd |
        // | AND CCR, Wait for int. | CC=CC&n,E=1,
        // | cwai 3c ? 2 -- - - -- - - -- - - -- - - cc&=im;wait 7 6 6 6 6 6
        switch (instructionCycleNum++) {
          // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_CC_MASK_PC
          case 1:
            ccMask = fetch(programCounter++);
            break;

          // FETCH_IGNORE_PC
          case 2:
            fetch(programCounter);
            setCC(getCC() & ccMask);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            entireFlag = true;
            break;

          // WRITE_PC_LOW_SP
          case 4:
            write(--stackPointer, (programCounter & 0xff));
            break;

          // WRITE_PC_HIGH_SP
          case 5:
            write(--stackPointer, (programCounter >> 8) & 0xff);
            break;

          // WRITE_USER_STACK_LOW_SP
          case 6:
            write(--stackPointer, (userStackPointer & 0xff));
            break;

          // WRITE_USER_STACK_HIGH_SP
          case 7:
            write(--stackPointer, (userStackPointer >> 8) & 0xff);
            break;

          // WRITE_Y_REGISTER_LOW_SP
          case 8:
            write(--stackPointer, (indexRegisterY & 0xff));
            break;

          // WRITE_Y_REGISTER_HIGH_SP
          case 9:
            write(--stackPointer, (indexRegisterY >> 8) & 0xff);
            break;

          // WRITE_X_REGISTER_LOW_SP
          case 10:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_X_REGISTER_HIGH_SP
          case 11:
            write(--stackPointer, (indexRegisterX >> 8) & 0xff);
            break;

          // WRITE_DP_REGISTER_SP
          case 12:
            write(--stackPointer, (directPageRegister & 0xff));
            break;

          // WRITE_B_REGISTER_SP
          case 13:
            write(--stackPointer, (accumulatorB & 0xff));
            break;

          // WRITE_A_REGISTER_SP
          case 14:
            write(--stackPointer, (accumulatorA & 0xff));
            break;

          // WRITE_CC_REGISTER_SP
          case 15:
            write(--stackPointer, (getCC() & 0xff));
            break;

          // DO

          // FETCH_IGNORE_FFFF
          case 16:
            fetch(0xffff);

            // WHILE_INTERRUPT_NOT_PRESENT (WAIT)
            
            if (((interruptStatus & S_NMI) != 0) && nmiArmed) {
              // NMI has been signalled. Prepare to read vector.
              vectorAddressHi = NMI_VECTOR_HI;
              vectorAddressLo = NMI_VECTOR_LO;
              irqDisableFlag = true;
              firqDisableFlag = true;
              // NMI is automatically cleared
              interruptStatus &= ~S_NMI;
            }
            else if ((interruptStatus & S_FIRQ) != 0 && !firqDisableFlag) {
              // FIRQ has been signalled. Prepare to read vector.
              vectorAddressHi = FIRQ_VECTOR_HI;
              vectorAddressLo = FIRQ_VECTOR_LO;
              irqDisableFlag = true;
              firqDisableFlag = true;
            }
            else if ((interruptStatus & S_IRQ) != 0 && !irqDisableFlag) {
              // IRQ has been signalled. Prepare to read vector.
              vectorAddressHi = IRQ_VECTOR_HI;
              vectorAddressLo = IRQ_VECTOR_LO;
              irqDisableFlag = true;
            }
            else {
              // No interrupt. Decremenet by 1 so that we stay in this wait state.
              instructionCycleNum = instructionCycleNum - 1;
            }
            break;

          // FETCH_INT_VECTOR_HIGH_FFFX
          case 17:
            effectiveAddress = (fetch(vectorAddressHi) << 8);
            break;

          // FETCH_INT_VECTOR_LOW_FFFY
          case 18:
            effectiveAddress = (effectiveAddress & 0xFF00) | fetch(vectorAddressLo);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 19:
            fetch(0xffff);
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = fetch(programCounter++);
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // MUL INHERENT
      case 61: {
        // | 3D 0061 | MUL | INHERENT | 11 | 1 | --a-a |
        // | Multiply | D=A*B
        // | mul -- - - -- - - -- - - -- - - 3d ? 1 d=a*b - - - x - 4
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC
          case 1:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 4:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 5:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 6:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 7:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 8:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 9:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 10:
            fetch(0xffff);
            setD(mul(accumulatorA, accumulatorB));
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // RESET* INHERENT
      case 62: {
        // | 3E 0062 | RESET* | INHERENT | * | 1 | ***** |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC
          case 1:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            // NOTE: Does not set the entireFlag.
            break;

          // WRITE_PC_LOW_SP
          case 3:
            write(--stackPointer, (programCounter & 0xff));
            break;

          // WRITE_PC_HIGH_SP
          case 4:
            write(--stackPointer, (programCounter >> 8) & 0xff);
            break;

          // WRITE_USER_STACK_LOW_SP
          case 5:
            write(--stackPointer, (userStackPointer & 0xff));
            break;

          // WRITE_USER_STACK_HIGH_SP
          case 6:
            write(--stackPointer, (userStackPointer >> 8) & 0xff);
            break;

          // WRITE_Y_REGISTER_LOW_SP
          case 7:
            write(--stackPointer, (indexRegisterY & 0xff));
            break;

          // WRITE_Y_REGISTER_HIGH_SP
          case 8:
            write(--stackPointer, (indexRegisterY >> 8) & 0xff);
            break;

          // WRITE_X_REGISTER_LOW_SP
          case 9:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_X_REGISTER_HIGH_SP
          case 10:
            write(--stackPointer, (indexRegisterX >> 8) & 0xff);
            break;

          // WRITE_DP_REGISTER_SP
          case 11:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_B_REGISTER_SP
          case 12:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_A_REGISTER_SP
          case 13:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_CC_REGISTER_SP
          case 14:
            write(--stackPointer, (getCC() & 0xff));
            break;

          // FETCH_IGNORE_FFFF
          case 15:
            fetch(0xffff);
            irqDisableFlag = true;
            firqDisableFlag = true;
            break;

          // FETCH_INT_VECTOR_HIGH_FFFE
          case 16:
            effectiveAddress = (fetch(RESET_VECTOR_HI) << 8);
            break;

          // FETCH_INT_VECTOR_LOW_FFFF
          case 17:
            effectiveAddress = (effectiveAddress & 0xFF00) | fetch(RESET_VECTOR_LO);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 18:
            fetch(0xffff);
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SWI INHERENT
      case 63: {
        // | 3F 0063 | SWI | INHERENT | 19 | 1 | ----- |
        // | Software Interrupt 1 | -[S]={regs}
        // | swi -- - - -- - - -- - - -- - - 3f ? 1 swi - 1 - - - -
        switch (instructionCycleNum++) {
          // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

          // FETCH_IGNORE_PC
          case 1:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            entireFlag = true;
            break;

          // WRITE_PC_LOW_SP
          case 3:
            write(--stackPointer, (programCounter & 0xff));
            break;

          // WRITE_PC_HIGH_SP
          case 4:
            write(--stackPointer, (programCounter >> 8) & 0xff);
            break;

          // WRITE_USER_STACK_LOW_SP
          case 5:
            write(--stackPointer, (userStackPointer & 0xff));
            break;

          // WRITE_USER_STACK_HIGH_SP
          case 6:
            write(--stackPointer, (userStackPointer >> 8) & 0xff);
            break;

          // WRITE_Y_REGISTER_LOW_SP
          case 7:
            write(--stackPointer, (indexRegisterY & 0xff));
            break;

          // WRITE_Y_REGISTER_HIGH_SP
          case 8:
            write(--stackPointer, (indexRegisterY >> 8) & 0xff);
            break;

          // WRITE_X_REGISTER_LOW_SP
          case 9:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_X_REGISTER_HIGH_SP
          case 10:
            write(--stackPointer, (indexRegisterX >> 8) & 0xff);
            break;

          // WRITE_DP_REGISTER_SP
          case 11:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_B_REGISTER_SP
          case 12:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_A_REGISTER_SP
          case 13:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_CC_REGISTER_SP
          case 14:
            write(--stackPointer, (getCC() & 0xff));
            break;

          // FETCH_IGNORE_FFFF
          case 15:
            fetch(0xffff);
            irqDisableFlag = true;
            firqDisableFlag = true;
            break;

          // FETCH_INT_VECTOR_HIGH_FFFA
          case 16:
            effectiveAddress = (fetch(SWI_VECTOR_HI) << 8);
            break;

          // FETCH_INT_VECTOR_LOW_FFFB
          case 17:
            effectiveAddress = (effectiveAddress & 0xFF00) | fetch(SWI_VECTOR_LO);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 18:
            fetch(0xffff);
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // NEGA INHERENT
      case 64: {
        // | 40 0064 | NEGA | INHERENT | 2 | 1 | uaaaa |
        // | Negate accumulator | a=-a
        // | nega -- - - -- - - -- - - -- - - 40 1 1 a=-a - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorA = neg(accumulatorA);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [65] ILLEGAL
      case 65:
        illegal();
        break;

      // [66] ILLEGAL
      case 66:
        illegal();
        break;

      // COMA INHERENT
      case 67: {
        // | 43 0067 | COMA | INHERENT | 2 | 1 | -aa01 |
        // | Complement accumulator | a=~a
        // | coma -- - - -- - - -- - - -- - - 43 1 1 a=~a - - x x 0 1
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorA = com(accumulatorA);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LSRA INHERENT
      case 68: {
        // | 44 0068 | LSRA | INHERENT | 2 | 1 | -0a-s |
        // | Logical Shift Right | d=->{C,d,0}
        // | lsra -- - - -- - - -- - - -- - - 44 1 1 (u)a>>=1 - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorA = lsr(accumulatorA);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [69] ILLEGAL
      case 69:
        illegal();
        break;

      // RORA INHERENT
      case 70: {
        // | 46 0070 | RORA | INHERENT | 2 | 1 | -aa-s |
        // | Rotate Right acc. | a=->{C,a}
        // | rora -- - - -- - - -- - - -- - - 46 1 1 a=ror(a) - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorA = ror(accumulatorA);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ASRA INHERENT
      case 71: {
        // | 47 0071 | ASRA | INHERENT | 2 | 1 | uaa-s |
        // | Arithmetic Shift Right | a=a/2
        // | asra -- - - -- - - -- - - -- - - 47 1 1 (i)a>>=1 - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorA = asr(accumulatorA);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ASLA INHERENT
      case 72: {
        // | 48 0072 | LSLA/ASLA | INHERENT | 2 | 1 | naaas |
        // | Arithmetic Shift Left | a=a*2
        // | asla -- - - -- - - -- - - -- - - 48 1 1 a<<=1 - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorA = asl(accumulatorA);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ROLA INHERENT
      case 73: {
        // | 49 0073 | ROLA | INHERENT | 2 | 1 | -aaas |
        // | Rotate Left acc. | a={C,a}<-
        // | rola -- - - -- - - -- - - -- - - 49 1 1 a=rol(a) - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorA = rol(accumulatorA);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // DECA INHERENT
      case 74: {
        // | 4A 0074 | DECA | INHERENT | 2 | 1 | -aaa- |
        // | Decrement accumulator | a=a-1
        // | deca -- - - -- - - -- - - -- - - 4a 1 1 a-=1 - - x x x -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorA = dec(accumulatorA);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [75] ILLEGAL
      case 75:
        illegal();
        break;

      // INCA INHERENT
      case 76: {
        // | 4C 0076 | INCA | INHERENT | 2 | 1 | -aaa- |
        // | Increment accumulator | a=a+1
        // | inca -- - - -- - - -- - - -- - - 4c 1 1 a+=1 - - x x x -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorA = inc(accumulatorA);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // TSTA INHERENT
      case 77: {
        // | 4D 0077 | TSTA | INHERENT | 2 | 1 | -aa0- |
        // | Test accumulator | a
        // | tsta -- - - -- - - -- - - -- - - 4d 1 1 a-0 - - x x 0 0
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            tst(accumulatorA);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [78] ILLEGAL
      case 78:
        illegal();
        break;

      // CLRA INHERENT
      case 79: {
        // | 4F 0079 | CLRA | INHERENT | 2 | 1 | -0100 |
        // | Clear accumulator | a=0
        // | clra -- - - -- - - -- - - -- - - 4f 1 1 a=0 - - x x 0 0
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorA = clr();
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // NEGB INHERENT
      case 80: {
        // | 50 0080 | NEGB | INHERENT | 2 | 1 | uaaaa |
        // | negb -- - - -- - - -- - - -- - - 50 1 1 b=-b - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorB = neg(accumulatorB);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [81] ILLEGAL
      case 81:
        illegal();
        break;

      // [82] ILLEGAL
      case 82:
        illegal();
        break;

      // COMB INHERENT
      case 83: {
        // | 53 0083 | COMB | INHERENT | 2 | 1 | -aa01 |
        // | comb -- - - -- - - -- - - -- - - 53 1 1 b=~b - - x x 0 1
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorB = com(accumulatorB);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LSRB INHERENT
      case 84: {
        // | 54 0084 | LSRB | INHERENT | 2 | 1 | -0a-s |
        // | lsrb -- - - -- - - -- - - -- - - 54 1 1 (u)b>>=1 - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorB = lsr(accumulatorB);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [85] ILLEGAL
      case 85:
        illegal();
        break;

      // RORB INHERENT
      case 86: {
        // | 56 0086 | RORB | INHERENT | 2 | 1 | -aa-s |
        // | rorb -- - - -- - - -- - - -- - - 56 1 1 b=ror(b) - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorB = ror(accumulatorB);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ASRB INHERENT
      case 87: {
        // | 57 0087 | ASRB | INHERENT | 2 | 1 | uaa-s |
        // | asrb -- - - -- - - -- - - -- - - 57 1 1 (i)b>>=1 - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorB = asr(accumulatorB);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ASLB INHERENT
      case 88: {
        // | 58 0088 | LSLB/ASLB | INHERENT | 2 | 1 | naaas |
        // | aslb -- - - -- - - -- - - -- - - 58 1 1 b<<=1 - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorB = asl(accumulatorB);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ROLB INHERENT
      case 89: {
        // | 59 0089 | ROLB | INHERENT | 2 | 1 | -aaas |
        // | rolb -- - - -- - - -- - - -- - - 59 1 1 b=rol(b) - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorB = rol(accumulatorB);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // DECB INHERENT
      case 90: {
        // | 5A 0090 | DECB | INHERENT | 2 | 1 | -aaa- |
        // | decb -- - - -- - - -- - - -- - - 5a 1 1 b-=1 - - x x x -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorB = dec(accumulatorB);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [91] ILLEGAL
      case 91:
        illegal();
        break;

      // INCB INHERENT
      case 92: {
        // | 5C 0092 | INCB | INHERENT | 2 | 1 | -aaa- |
        // | incb -- - - -- - - -- - - -- - - 5c 1 1 b+=1 - - x x x -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorB = inc(accumulatorB);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // TSTB INHERENT
      case 93: {
        // | 5D 0093 | TSTB | INHERENT | 2 | 1 | -aa0- |
        // | tstb -- - - -- - - -- - - -- - - 5d 1 1 b-0 - - x x 0 0
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            tst(accumulatorB);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [94] ILLEGAL
      case 94:
        illegal();
        break;

      // CLRB INHERENT
      case 95: {
        // | 5F 0095 | CLRB | INHERENT | 2 | 1 | -0100 |
        // | clrb -- - - -- - - -- - - -- - - 5f 1 1 b=0 - - x x 0 0
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_IGNORE_PC (EXECUTE)
          case 1:
            fetch(programCounter);
            accumulatorB = clr();
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // NEG INDEXED
      case 96: {
        // | 60 0096 | NEG | INDEXED | 6 | 2 | uaaaa |
        // | Negate | d=-d
        // | neg -- - - -- - - 60 6 2 70 6 3 -- - - m=-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 3:
            fetch(0xffff);
            dataBusBuffer = neg(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 4:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [97] ILLEGAL
      case 97:
        illegal();
        break;

      // [98] ILLEGAL
      case 98:
        illegal();
        break;

      // COM INDEXED
      case 99: {
        // | 63 0099 | COM | INDEXED | 6 | 2 | -aa01 |
        // | Complement | d=~d
        // | com -- - - -- - - 63 6 2 73 6 3 -- - - m=~m - - x x 0 1
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 3:
            fetch(0xffff);
            dataBusBuffer = com(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 4:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LSR INDEXED
      case 100: {
        // | 64 0100 | LSR | INDEXED | 6 | 2 | -0a-s |
        // | Logical Shift Right | d=->{C,d,0}
        // | lsr -- - - -- - - 64 6 2 74 6 3 -- - - (u)m>>=1 - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 3:
            fetch(0xffff);
            dataBusBuffer = lsr(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 4:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [101] ILLEGAL
      case 101:
        illegal();
        break;

      // ROR INDEXED
      case 102: {
        // | 66 0102 | ROR | INDEXED | 6 | 2 | -aa-s |
        // | Rotate Right | d=->{C,d}
        // | ror -- - - -- - - 66 6 2 76 6 3 -- - - m=ror(m) - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 3:
            fetch(0xffff);
            dataBusBuffer = ror(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 4:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ASR INDEXED
      case 103: {
        // | 67 0103 | ASR | INDEXED | 6 | 2 | uaa-s |
        // | Arithmetic Shift Right | d=d/2
        // | asr -- - - -- - - 67 6 2 77 6 3 -- - - (i)m>>=1 - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 3:
            fetch(0xffff);
            dataBusBuffer = asr(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 4:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ASL INDEXED
      case 104: {
        // | 68 0104 | LSL/ASL | INDEXED | 6 | 2 | naaas |
        // | Arithmetic Shift Left | d=d*2
        // | asl -- - - -- - - 68 6 2 78 6 3 -- - - m<<=1 - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 3:
            fetch(0xffff);
            dataBusBuffer = asl(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 4:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ROL INDEXED
      case 105: {
        // | 69 0105 | ROL | INDEXED | 6 | 2 | -aaas |
        // | Rotate Left | d={C,d}<-
        // | rol -- - - -- - - 69 6 2 79 6 3 -- - - m=rol(m) - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 3:
            fetch(0xffff);
            dataBusBuffer = rol(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 4:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // DEC INDEXED
      case 106: {
        // | 6A 0106 | DEC | INDEXED | 6 | 2 | -aaa- |
        // | Decrement | d=d-1
        // | dec -- - - -- - - 6a 6 2 7a 6 3 -- - - m-=1 - - x x x -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 3:
            fetch(0xffff);
            dataBusBuffer = dec(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 4:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [107] ILLEGAL
      case 107:
        illegal();
        break;

      // INC INDEXED
      case 108: {
        // | 6C 0108 | INC | INDEXED | 6 | 2 | -aaa- |
        // | Increment | d=d+1
        // | inc -- - - -- - - 6c 6 2 7c 6 3 -- - - m+=1 - - x x x -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 3:
            fetch(0xffff);
            dataBusBuffer = inc(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 4:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // TST INDEXED
      case 109: {
        // | 6D 0109 | TST | INDEXED | 6 | 2 | -aa0- |
        // | Test | s
        // | tst -- - - -- - - 6d 4 2 7d 4 3 -- - - m-0 - - x x 0 0
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 3:
            fetch(0xffff);
            tst(inputDataLatch);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // JMP INDEXED
      case 110: {
        // | 6E 0110 | JMP | INDEXED | 3 | 2 | ----- |
        // | Jump | PC=EAs
        // | jmp -- - - 0e 3 2 6e 3 2 7e 3 3 -- - - jmp - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE (EXECUTE)
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            programCounter = effectiveAddress;  // Unusual, in that there is no additional cycle to set EA after returning from Index mode steps.
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CLR INDEXED
      case 111: {
        // | 6F 0111 | CLR | INDEXED | 6 | 2 | -0100 |
        // | Clear | d=0
        // | clr -- - - -- - - 6f 5 2 7f 5 3 -- - - m=0 - - x x 0 0
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 3:
            fetch(0xffff);
            dataBusBuffer = clr();
            break;

          // WRITE_DATA_EA
          case 4:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // NEG EXTENDED
      case 112: {
        // | 70 0112 | NEG | EXTENDED | 7 | 3 | uaaaa |
        // | Negate | d=-d
        // | neg -- - - -- - - 60 6 2 70 6 3 -- - - m=-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            dataBusBuffer = neg(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 6:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [113] ILLEGAL
      case 113:
        illegal();
        break;

      // [114] ILLEGAL
      case 114:
        illegal();
        break;

      // COM EXTENDED
      case 115: {
        // | 73 0115 | COM | EXTENDED | 7 | 3 | -aa01 |
        // | Complement | d=~d
        // | com -- - - -- - - 63 6 2 73 6 3 -- - - m=~m - - x x 0 1
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            dataBusBuffer = com(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 6:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LSR EXTENDED
      case 116: {
        // | 74 0116 | LSR | EXTENDED | 7 | 3 | -0a-s |
        // | Logical Shift Right | d=->{C,d,0}
        // | lsr -- - - -- - - 64 6 2 74 6 3 -- - - (u)m>>=1 - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            dataBusBuffer = lsr(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 6:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [117] ILLEGAL
      case 117:
        illegal();
        break;

      // ROR EXTENDED
      case 118: {
        // | 76 0118 | ROR | EXTENDED | 7 | 3 | -aa-s |
        // | Rotate Right | d=->{C,d}
        // | ror -- - - -- - - 66 6 2 76 6 3 -- - - m=ror(m) - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            dataBusBuffer = ror(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 6:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ASR EXTENDED
      case 119: {
        // | 77 0119 | ASR | EXTENDED | 7 | 3 | uaa-s |
        // | Arithmetic Shift Right | d=d/2
        // | asr -- - - -- - - 67 6 2 77 6 3 -- - - (i)m>>=1 - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            dataBusBuffer = asr(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 6:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ASL EXTENDED
      case 120: {
        // | 78 0120 | LSL/ASL | EXTENDED | 7 | 3 | naaas |
        // | Arithmetic Shift Left | d=d*2
        // | asl -- - - -- - - 68 6 2 78 6 3 -- - - m<<=1 - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            dataBusBuffer = asl(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 6:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ROL EXTENDED
      case 121: {
        // | 79 0121 | ROL | EXTENDED | 7 | 3 | -aaas |
        // | Rotate Left | d={C,d}<-
        // | rol -- - - -- - - 69 6 2 79 6 3 -- - - m=rol(m) - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            dataBusBuffer = rol(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 6:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // DEC EXTENDED
      case 122: {
        // | 7A 0122 | DEC | EXTENDED | 7 | 3 | -aaa- |
        // | Decrement | d=d-1
        // | dec -- - - -- - - 6a 6 2 7a 6 3 -- - - m-=1 - - x x x -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            dataBusBuffer = dec(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 6:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [123] ILLEGAL
      case 123:
        illegal();
        break;

      // INC EXTENDED
      case 124: {
        // | 7C 0124 | INC | EXTENDED | 7 | 3 | -aaa- |
        // | Increment | d=d+1
        // | inc -- - - -- - - 6c 6 2 7c 6 3 -- - - m+=1 - - x x x -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            dataBusBuffer = inc(inputDataLatch);
            break;

          // WRITE_DATA_EA
          case 6:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // TST EXTENDED
      case 125: {
        // | 7D 0125 | TST | EXTENDED | 7 | 3 | -aa0- |
        // | Test | s
        // | tst -- - - -- - - 6d 4 2 7d 4 3 -- - - m-0 - - x x 0 0
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            tst(inputDataLatch);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 6:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // JMP EXTENDED
      case 126: {
        // | 7E 0126 | JMP | EXTENDED | 3 | 3 | ----- |
        // | Jump | PC=EAs
        // | jmp -- - - 0e 3 2 6e 3 2 7e 3 3 -- - - jmp - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CLR EXTENDED
      case 127: {
        // | 7F 0127 | CLR | EXTENDED | 7 | 3 | -0100 |
        // | Clear | d=0
        // | clr -- - - -- - - 6f 5 2 7f 5 3 -- - - m=0 - - x x 0 0
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            dataBusBuffer = clr();
            break;

          // WRITE_DATA_EA
          case 6:
            write(effectiveAddress, dataBusBuffer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SUBA IMMEDIATE
      case 128: {
        // | 80 0128 | SUBA | IMMEDIATE | 2 | 2 | uaaaa |
        // | Subtract | a=a-s
        // | suba 80 2 2 90 3 2 a0 4 2 b0 4 3 -- - - a-=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorA = sub8Bit(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPA IMMEDIATE
      case 129: {
        // | 81 0129 | CMPA | IMMEDIATE | 2 | 2 | uaaaa |
        // | Compare | a-s
        // | cmpa 81 2 2 91 3 2 a1 4 2 b1 4 3 -- - - a-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            sub8Bit(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SBCA IMMEDIATE
      case 130: {
        // | 82 0130 | SBCA | IMMEDIATE | 2 | 2 | uaaaa |
        // | Subtract with Carry | a=a-s-C
        // | sbca 82 2 2 92 3 2 a2 4 2 b2 4 3 -- - - a-=m+c - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorA = sbc(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SUBD IMMEDIATE
      case 131: {
        // | 83 0131 | SUBD | IMMEDIATE | 4 | 3 | -aaaa |
        // | Subtract Double acc. | D=D-s
        // | subd 83 3 3 93 4 2 a3 5 2 b3 5 3 -- - - d-=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_HIGH_PC
          case 1:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(programCounter++) << 8);
            break;

          // FETCH_DATA_LOW_PC
          case 2:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 3:
            fetch(0xffff);
            setD(sub16Bit(getD(), inputDataLatch));
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ANDA IMMEDIATE
      case 132: {
        // | 84 0132 | ANDA | IMMEDIATE | 2 | 2 | -aa0- |
        // | Logical AND | a=a&s
        // | anda 84 2 2 94 3 2 a4 4 2 b4 4 3 -- - - a&=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorA = and(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BITA IMMEDIATE
      case 133: {
        // | 85 0133 | BITA | IMMEDIATE | 2 | 2 | -aa0- |
        // | Bit Test accumulator | a&s
        // | bita 85 2 2 95 3 2 a5 4 2 b5 4 3 -- - - a&m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            and(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDA IMMEDIATE
      case 134: {
        // | 86 0134 | LDA | IMMEDIATE | 2 | 2 | -aa0- |
        // | Load accumulator | a=s
        // | lda 86 2 2 96 3 2 a6 4 2 b6 4 3 -- - - a=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorA = ld8Bit(inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [135] ILLEGAL
      case 135:
        illegal();
        break;

      // EORA IMMEDIATE
      case 136: {
        // | 88 0136 | EORA | IMMEDIATE | 2 | 2 | -aa0- |
        // | Logical Exclusive OR | a=axs
        // | eora 88 2 2 98 3 2 a8 4 2 b8 4 3 -- - - a^=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorA = eor(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADCA IMMEDIATE
      case 137: {
        // | 89 0137 | ADCA | IMMEDIATE | 2 | 2 | aaaaa |
        // | Add with Carry | a=a+s+C
        // | adca 89 2 2 99 3 2 a9 4 2 b9 4 3 -- - - a+=m+c x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorA = adc(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ORA IMMEDIATE
      case 138: {
        // | 8A 0138 | ORA | IMMEDIATE | 2 | 2 | -aa0- |
        // | Logical inclusive OR | a=avs
        // | ora 8a 2 2 9a 3 2 aa 4 2 ba 4 3 -- - - a|=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorA = or(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADDA IMMEDIATE
      case 139: {
        // | 8B 0139 | ADDA | IMMEDIATE | 2 | 2 | aaaaa |
        // | Add | a=a+s
        // | adda 8b 2 2 9b 3 2 ab 4 2 bb 4 3 -- - - a+=m x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorA = add(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPX IMMEDIATE
      case 140: {
        // | 8C 0140 | CMPX | IMMEDIATE | 4 | 3 | -aaaa |
        // | cmpx 8c 3 3 9c 4 2 ac 5 2 bc 5 3 -- - - x-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_HIGH_PC
          case 1:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(programCounter++) << 8);
            break;

          // FETCH_DATA_LOW_PC
          case 2:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 3:
            fetch(0xffff);
            sub16Bit(indexRegisterX, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BSR RELATIVE
      case 141: {
        // | 8D 0141 | BSR | RELATIVE | 7 | 2 | ----- |
        // | Branch to Subroutine | -[S]=PC,BRA
        // | bsr 8d 5 2 -- - - -- - - -- - - -- - - bsr - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OFFSET_PC
          case 1:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            break;

          // FETCH_IGNORE_EA
          case 3:
            fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF
          case 4:
            fetch(0xffff);
            break;

          // WRITE_RETURN_ADDR_LOW_SP
          case 5:
            write(--stackPointer, (programCounter & 0xff));
            break;

          // WRITE_RETURN_ADDR_HIGH_SP (EXECUTE)
          case 6:
            write(--stackPointer, (programCounter >> 8) & 0xff);
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDX IMMEDIATE
      case 142: {
        // | 8E 0142 | LDX | IMMEDIATE | 3 | 3 | -aa0- |
        // | ldx 8e 3 3 9e 4 2 ae 5 2 be 5 3 -- - - x=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_REGISTER_HIGH_PC
          case 1:
            indexRegisterX = (indexRegisterX & 0x00FF) | (fetch(programCounter++) << 8);
            break;

          // FETCH_REGISTER_LOW_PC (EXECUTE)
          case 2:
            indexRegisterX = (indexRegisterX & 0xFF00) | fetch(programCounter++);
            ld16Bit(indexRegisterX);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [143] ILLEGAL
      case 143:
        illegal();
        break;

      // SUBA DIRECT
      case 144: {
        // | 90 0144 | SUBA | DIRECT | 4 | 2 | uaaaa |
        // | Subtract | a=a-s
        // | suba 80 2 2 90 3 2 a0 4 2 b0 4 3 -- - - a-=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = sub8Bit(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPA DIRECT
      case 145: {
        // | 91 0145 | CMPA | DIRECT | 4 | 2 | uaaaa |
        // | Compare | a-s
        // | cmpa 81 2 2 91 3 2 a1 4 2 b1 4 3 -- - - a-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            sub8Bit(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SBCA DIRECT
      case 146: {
        // | 92 0146 | SBCA | DIRECT | 4 | 2 | uaaaa |
        // | Subtract with Carry | a=a-s-C
        // | sbca 82 2 2 92 3 2 a2 4 2 b2 4 3 -- - - a-=m+c - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = sbc(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SUBD DIRECT
      case 147: {
        // | 93 0147 | SUBD | DIRECT | 6 | 2 | -aaaa |
        // | Subtract Double acc. | D=D-s
        // | subd 83 3 3 93 4 2 a3 5 2 b3 5 3 -- - - d-=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_HIGH_EA
          case 3:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 4:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            setD(sub16Bit(getD(), inputDataLatch));
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ANDA DIRECT
      case 148: {
        // | 94 0148 | ANDA | DIRECT | 4 | 2 | -aa0- |
        // | Logical AND | a=a&s
        // | anda 84 2 2 94 3 2 a4 4 2 b4 4 3 -- - - a&=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = and(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BITA DIRECT
      case 149: {
        // | 95 0149 | BITA | DIRECT | 4 | 2 | -aa0- |
        // | Bit Test accumulator | a&s
        // | bita 85 2 2 95 3 2 a5 4 2 b5 4 3 -- - - a&m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            and(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDA DIRECT
      case 150: {
        // | 96 0150 | LDA | DIRECT | 4 | 2 | -aa0- |
        // | Load accumulator | a=s
        // | lda 86 2 2 96 3 2 a6 4 2 b6 4 3 -- - - a=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = ld8Bit(inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STA DIRECT
      case 151: {
        // | 97 0151 | STA | DIRECT | 4 | 2 | -aa0- |
        // | Store accumultor | d=a
        // | sta -- - - 97 3 2 a7 4 2 b7 4 3 -- - - m=a - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // WRITE_REGISTER_EA (EXECUTE)
          case 3:
            write(effectiveAddress, (accumulatorA & 0xFF));
            st8Bit(accumulatorA);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // EORA DIRECT
      case 152: {
        // | 98 0152 | EORA | DIRECT | 4 | 2 | -aa0- |
        // | Logical Exclusive OR | a=axs
        // | eora 88 2 2 98 3 2 a8 4 2 b8 4 3 -- - - a^=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = eor(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADCA DIRECT
      case 153: {
        // | 99 0153 | ADCA | DIRECT | 4 | 2 | aaaaa |
        // | Add with Carry | a=a+s+C
        // | adca 89 2 2 99 3 2 a9 4 2 b9 4 3 -- - - a+=m+c x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = adc(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ORA DIRECT
      case 154: {
        // | 9A 0154 | ORA | DIRECT | 4 | 2 | -aa0- |
        // | Logical inclusive OR | a=avs
        // | ora 8a 2 2 9a 3 2 aa 4 2 ba 4 3 -- - - a|=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = or(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADDA DIRECT
      case 155: {
        // | 9B 0155 | ADDA | DIRECT | 4 | 2 | aaaaa |
        // | Add | a=a+s
        // | adda 8b 2 2 9b 3 2 ab 4 2 bb 4 3 -- - - a+=m x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = add(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPX DIRECT
      case 156: {
        // | 9C 0156 | CMPX | DIRECT | 6 | 2 | -aaaa |
        // | cmpx 8c 3 3 9c 4 2 ac 5 2 bc 5 3 -- - - x-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_HIGH_EA
          case 3:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 4:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            sub16Bit(indexRegisterX, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // JSR DIRECT
      case 157: {
        // | 9D 0157 | JSR | DIRECT | 7 | 2 | ----- |
        // | Jump to Subroutine | -[S]=PC,JMP
        // | jsr -- - - 9d 5 2 ad 5 2 bd 6 3 -- - - jsr - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_IGNORE_EA
          case 3:
            fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF
          case 4:
            fetch(0xffff);
            break;

          // WRITE_PC_LOW_SP
          case 5:
            write(--stackPointer, (programCounter & 0xff));
            break;

          // WRITE_PC_HIGH_SP (EXECUTE)
          case 6:
            write(--stackPointer, (programCounter >> 8) & 0xff);
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDX DIRECT
      case 158: {
        // | 9E 0158 | LDX | DIRECT | 5 | 2 | -aa0- |
        // | ldx 8e 3 3 9e 4 2 ae 5 2 be 5 3 -- - - x=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_REGISTER_HIGH_EA
          case 3:
            indexRegisterX = (indexRegisterX & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_REGISTER_LOW_EA (EXECUTE)
          case 4:
            indexRegisterX = (indexRegisterX & 0xFF00) | fetch(effectiveAddress + 1);
            ld16Bit(indexRegisterX);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STX DIRECT
      case 159: {
        // | 9F 0159 | STX | DIRECT | 5 | 2 | -aa0- |
        // | stx -- - - 9f 4 2 af 5 2 bf 5 3 -- - - x=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // WRITE_REGISTER_HIGH_EA
          case 3:
            write(effectiveAddress, (indexRegisterX >> 8) & 0xFF);
            break;

          // WRITE_REGISTER_LOW_EA (EXECUTE)
          case 4:
            write(effectiveAddress + 1, (indexRegisterX & 0xFF));
            st16Bit(indexRegisterX);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SUBA INDEXED
      case 160: {
        // | A0 0160 | SUBA | INDEXED | 4 | 2 | uaaaa |
        // | Subtract | a=a-s
        // | suba 80 2 2 90 3 2 a0 4 2 b0 4 3 -- - - a-=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = sub8Bit(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPA INDEXED
      case 161: {
        // | A1 0161 | CMPA | INDEXED | 4 | 2 | uaaaa |
        // | Compare | a-s
        // | cmpa 81 2 2 91 3 2 a1 4 2 b1 4 3 -- - - a-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            sub8Bit(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SBCA INDEXED
      case 162: {
        // | A2 0162 | SBCA | INDEXED | 4 | 2 | uaaaa |
        // | Subtract with Carry | a=a-s-C
        // | sbca 82 2 2 92 3 2 a2 4 2 b2 4 3 -- - - a-=m+c - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = sbc(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SUBD INDEXED
      case 163: {
        // | A3 0163 | SUBD | INDEXED | 6 | 2 | -aaaa |
        // | Subtract Double acc. | D=D-s
        // | subd 83 3 3 93 4 2 a3 5 2 b3 5 3 -- - - d-=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_HIGH_EA
          case 2:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 3:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            setD(sub16Bit(getD(), inputDataLatch));
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ANDA INDEXED
      case 164: {
        // | A4 0164 | ANDA | INDEXED | 4 | 2 | -aa0- |
        // | Logical AND | a=a&s
        // | anda 84 2 2 94 3 2 a4 4 2 b4 4 3 -- - - a&=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = and(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BITA INDEXED
      case 165: {
        // | A5 0165 | BITA | INDEXED | 4 | 2 | -aa0- |
        // | Bit Test accumulator | a&s
        // | bita 85 2 2 95 3 2 a5 4 2 b5 4 3 -- - - a&m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            and(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDA INDEXED
      case 166: {
        // | A6 0166 | LDA | INDEXED | 4 | 2 | -aa0- |
        // | Load accumulator | a=s
        // | lda 86 2 2 96 3 2 a6 4 2 b6 4 3 -- - - a=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = ld8Bit(inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STA INDEXED
      case 167: {
        // | A7 0167 | STA | INDEXED | 4 | 2 | -aa0- |
        // | Store accumultor | d=a
        // | sta -- - - 97 3 2 a7 4 2 b7 4 3 -- - - m=a - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // WRITE_REGISTER_EA (EXECUTE)
          case 2:
            write(effectiveAddress, (accumulatorA & 0xFF));
            st8Bit(accumulatorA);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // EORA INDEXED
      case 168: {
        // | A8 0168 | EORA | INDEXED | 4 | 2 | -aa0- |
        // | Logical Exclusive OR | a=axs
        // | eora 88 2 2 98 3 2 a8 4 2 b8 4 3 -- - - a^=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = eor(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADCA INDEXED
      case 169: {
        // | A9 0169 | ADCA | INDEXED | 4 | 2 | aaaaa |
        // | Add with Carry | a=a+s+C
        // | adca 89 2 2 99 3 2 a9 4 2 b9 4 3 -- - - a+=m+c x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = adc(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ORA INDEXED
      case 170: {
        // | AA 0170 | ORA | INDEXED | 4 | 2 | -aa0- |
        // | Logical inclusive OR | a=avs
        // | ora 8a 2 2 9a 3 2 aa 4 2 ba 4 3 -- - - a|=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = or(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADDA INDEXED
      case 171: {
        // | AB 0171 | ADDA | INDEXED | 4 | 2 | aaaaa |
        // | Add | a=a+s
        // | adda 8b 2 2 9b 3 2 ab 4 2 bb 4 3 -- - - a+=m x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = add(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPX INDEXED
      case 172: {
        // | AC 0172 | CMPX | INDEXED | 6 | 2 | -aaaa |
        // | cmpx 8c 3 3 9c 4 2 ac 5 2 bc 5 3 -- - - x-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_HIGH_EA
          case 2:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 3:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            sub16Bit(indexRegisterX, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // JSR INDEXED
      case 173: {
        // | AD 0173 | JSR | INDEXED | 7 | 2 | ----- |
        // | Jump to Subroutine | -[S]=PC,JMP
        // | jsr -- - - 9d 5 2 ad 5 2 bd 6 3 -- - - jsr - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_IGNORE_EA
          case 2:
            fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // WRITE_PC_LOW_SP
          case 4:
            write(--stackPointer, (programCounter & 0xff));
            break;

          // WRITE_PC_HIGH_SP (EXECUTE)
          case 5:
            write(--stackPointer, (programCounter >> 8) & 0xff);
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDX INDEXED
      case 174: {
        // | AE 0174 | LDX | INDEXED | 5 | 2 | -aa0- |
        // | ldx 8e 3 3 9e 4 2 ae 5 2 be 5 3 -- - - x=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_REGISTER_HIGH_EA
          case 2:
            indexRegisterX = (indexRegisterX & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_REGISTER_LOW_EA (EXECUTE)
          case 3:
            indexRegisterX = (indexRegisterX & 0xFF00) | fetch(effectiveAddress + 1);
            ld16Bit(indexRegisterX);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STX INDEXED
      case 175: {
        // | AF 0175 | STX | INDEXED | 5 | 2 | -aa0- |
        // | stx -- - - 9f 4 2 af 5 2 bf 5 3 -- - - x=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // WRITE_REGISTER_HIGH_EA
          case 2:
            write(effectiveAddress, (indexRegisterX >> 8) & 0xFF);
            break;

          // WRITE_REGISTER_LOW_EA (EXECUTE)
          case 3:
            write(effectiveAddress + 1, (indexRegisterX & 0xFF));
            st16Bit(indexRegisterX);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SUBA EXTENDED
      case 176: {
        // | B0 0176 | SUBA | EXTENDED | 5 | 3 | uaaaa |
        // | Subtract | a=a-s
        // | suba 80 2 2 90 3 2 a0 4 2 b0 4 3 -- - - a-=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = sub8Bit(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPA EXTENDED
      case 177: {
        // | B1 0177 | CMPA | EXTENDED | 5 | 3 | uaaaa |
        // | Compare | a-s
        // | cmpa 81 2 2 91 3 2 a1 4 2 b1 4 3 -- - - a-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            sub8Bit(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SBCA EXTENDED
      case 178: {
        // | B2 0178 | SBCA | EXTENDED | 5 | 3 | uaaaa |
        // | Subtract with Carry | a=a-s-C
        // | sbca 82 2 2 92 3 2 a2 4 2 b2 4 3 -- - - a-=m+c - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = sbc(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SUBD EXTENDED
      case 179: {
        // | B3 0179 | SUBD | EXTENDED | 7 | 3 | -aaaa |
        // | Subtract Double acc. | D=D-s
        // | subd 83 3 3 93 4 2 a3 5 2 b3 5 3 -- - - d-=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_HIGH_EA
          case 4:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 5:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 6:
            fetch(0xffff);
            setD(sub16Bit(getD(), inputDataLatch));
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ANDA EXTENDED
      case 180: {
        // | B4 0180 | ANDA | EXTENDED | 5 | 3 | -aa0- |
        // | Logical AND | a=a&s
        // | anda 84 2 2 94 3 2 a4 4 2 b4 4 3 -- - - a&=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = and(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BITA EXTENDED
      case 181: {
        // | B5 0181 | BITA | EXTENDED | 5 | 3 | -aa0- |
        // | Bit Test accumulator | a&s
        // | bita 85 2 2 95 3 2 a5 4 2 b5 4 3 -- - - a&m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            and(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDA EXTENDED
      case 182: {
        // | B6 0182 | LDA | EXTENDED | 5 | 3 | -aa0- |
        // | Load accumulator | a=s
        // | lda 86 2 2 96 3 2 a6 4 2 b6 4 3 -- - - a=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = ld8Bit(inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STA EXTENDED
      case 183: {
        // | B7 0183 | STA | EXTENDED | 5 | 3 | -aa0- |
        // | Store accumultor | d=a
        // | sta -- - - 97 3 2 a7 4 2 b7 4 3 -- - - m=a - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // WRITE_REGISTER_EA (EXECUTE)
          case 4:
            write(effectiveAddress, (accumulatorA & 0xFF));
            st8Bit(accumulatorA);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // EORA EXTENDED
      case 184: {
        // | B8 0184 | EORA | EXTENDED | 5 | 3 | -aa0- |
        // | Logical Exclusive OR | a=axs
        // | eora 88 2 2 98 3 2 a8 4 2 b8 4 3 -- - - a^=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = eor(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADCA EXTENDED
      case 185: {
        // | B9 0185 | ADCA | EXTENDED | 5 | 3 | aaaaa |
        // | Add with Carry | a=a+s+C
        // | adca 89 2 2 99 3 2 a9 4 2 b9 4 3 -- - - a+=m+c x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = adc(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ORA EXTENDED
      case 186: {
        // | BA 0186 | ORA | EXTENDED | 5 | 3 | -aa0- |
        // | Logical inclusive OR | a=avs
        // | ora 8a 2 2 9a 3 2 aa 4 2 ba 4 3 -- - - a|=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = or(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADDA EXTENDED
      case 187: {
        // | BB 0187 | ADDA | EXTENDED | 5 | 3 | aaaaa |
        // | Add | a=a+s
        // | adda 8b 2 2 9b 3 2 ab 4 2 bb 4 3 -- - - a+=m x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorA = add(accumulatorA, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPX EXTENDED
      case 188: {
        // | BC 0188 | CMPX | EXTENDED | 7 | 3 | -aaaa |
        // | cmpx 8c 3 3 9c 4 2 ac 5 2 bc 5 3 -- - - x-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_HIGH_EA
          case 4:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 5:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 6:
            fetch(0xffff);
            sub16Bit(indexRegisterX, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // JSR EXTENDED
      case 189: {
        // | BD 0189 | JSR | EXTENDED | 8 | 3 | ----- |
        // | Jump to Subroutine | -[S]=PC,JMP
        // | jsr -- - - 9d 5 2 ad 5 2 bd 6 3 -- - - jsr - - - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_IGNORE_EA
          case 4:
            fetch(effectiveAddress);
            break;

          // FETCH_IGNORE_FFFF
          case 5:
            fetch(0xffff);
            break;

          // WRITE_PC_LOW_SP
          case 6:
            write(--stackPointer, (programCounter & 0xff));
            break;

          // WRITE_PC_HIGH_SP (EXECUTE)
          case 7:
            write(--stackPointer, (programCounter >> 8) & 0xff);
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDX EXTENDED
      case 190: {
        // | BE 0190 | LDX | EXTENDED | 6 | 3 | -aa0- |
        // | ldx 8e 3 3 9e 4 2 ae 5 2 be 5 3 -- - - x=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_REGISTER_HIGH_EA
          case 4:
            indexRegisterX = (indexRegisterX & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_REGISTER_LOW_EA (EXECUTE)
          case 5:
            indexRegisterX = (indexRegisterX & 0xFF00) | fetch(effectiveAddress + 1);
            ld16Bit(indexRegisterX);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STX EXTENDED
      case 191: {
        // | BF 0191 | STX | EXTENDED | 6 | 3 | -aa0- |
        // | stx -- - - 9f 4 2 af 5 2 bf 5 3 -- - - x=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // WRITE_REGISTER_HIGH_EA
          case 4:
            write(effectiveAddress, (indexRegisterX >> 8) & 0xFF);
            break;

          // WRITE_REGISTER_LOW_EA (EXECUTE)
          case 5:
            write(effectiveAddress + 1, (indexRegisterX & 0xFF));
            st16Bit(indexRegisterX);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SUBB IMMEDIATE
      case 192: {
        // | C0 0192 | SUBB | IMMEDIATE | 2 | 2 | uaaaa |
        // | subb c0 2 2 d0 3 2 e0 4 2 f0 4 3 -- - - b-=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorB = sub8Bit(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPB IMMEDIATE
      case 193: {
        // | C1 0193 | CMPB | IMMEDIATE | 2 | 2 | uaaaa |
        // | cmpb c1 2 2 d1 3 2 e1 4 2 f1 4 3 -- - - b-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            sub8Bit(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SBCB IMMEDIATE
      case 194: {
        // | C2 0194 | SBCB | IMMEDIATE | 2 | 2 | uaaaa |
        // | sbcb c2 2 2 d2 3 2 e2 4 2 f2 4 3 -- - - b-=m+c - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorB = sbc(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADDD IMMEDIATE
      case 195: {
        // | C3 0195 | ADDD | IMMEDIATE | 4 | 3 | -aaaa |
        // | Add to Double acc. | D=D+s
        // | addd c3 3 3 d3 4 2 e3 5 2 f3 5 3 -- - - d+=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_HIGH_PC
          case 1:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(programCounter++) << 8);
            break;

          // FETCH_DATA_LOW_PC
          case 2:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 3:
            fetch(0xffff);
            setD(addd(getD(), inputDataLatch));
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ANDB IMMEDIATE
      case 196: {
        // | C4 0196 | ANDB | IMMEDIATE | 2 | 2 | -aa0- |
        // | andb c4 2 2 d4 3 2 e4 4 2 f4 4 3 -- - - b&=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorB = and(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BITB IMMEDIATE
      case 197: {
        // | C5 0197 | BITB | IMMEDIATE | 2 | 2 | -aa0- |
        // | bitb c5 2 2 d5 3 2 e5 4 2 f5 4 3 -- - - b&m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            and(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDB IMMEDIATE
      case 198: {
        // | C6 0198 | LDB | IMMEDIATE | 2 | 2 | -aa0- |
        // | ldb c6 2 2 d6 3 2 e6 4 2 f6 4 3 -- - - b=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorB = ld8Bit(inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [199] ILLEGAL
      case 199:
        illegal();
        break;

      // EORB IMMEDIATE
      case 200: {
        // | C8 0200 | EORB | IMMEDIATE | 2 | 2 | -aa0- |
        // | eorb c8 2 2 d8 3 2 e8 4 2 f8 4 3 -- - - b^=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorB = eor(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADCB IMMEDIATE
      case 201: {
        // | C9 0201 | ADCB | IMMEDIATE | 2 | 2 | aaaaa |
        // | adcb c9 2 2 d9 3 2 e9 4 2 f9 4 3 -- - - b+=m+c x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorB = adc(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ORB IMMEDIATE
      case 202: {
        // | CA 0202 | ORB | IMMEDIATE | 2 | 2 | -aa0- |
        // | orb ca 2 2 da 3 2 ea 4 2 fa 4 3 -- - - b|=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorB = or(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADDB IMMEDIATE
      case 203: {
        // | CB 0203 | ADDB | IMMEDIATE | 2 | 2 | aaaaa |
        // | addb cb 2 2 db 3 2 eb 4 2 fb 4 3 -- - - b+=m x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_DATA_PC (EXECUTE)
          case 1:
            inputDataLatch = fetch(programCounter++);
            accumulatorB = add(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDD IMMEDIATE
      case 204: {
        // | CC 0204 | LDD | IMMEDIATE | 3 | 3 | -aa0- |
        // | Load Double acc. | D=s
        // | ldd cc 3 3 dc 4 2 ec 5 2 fc 5 3 -- - - d=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_REGISTER_HIGH_PC
          case 1:
            accumulatorA = fetch(programCounter++);
            break;

          // FETCH_REGISTER_LOW_PC (EXECUTE)
          case 2:
            accumulatorB = fetch(programCounter++);
            ld16Bit(getD());
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [205] ILLEGAL
      case 205:
        illegal();
        break;

      // LDU IMMEDIATE
      case 206: {
        // | CE 0206 | LDU | IMMEDIATE | 3 | 3 | -aa0- |
        // | Load User stack ptr | U=s
        // | ldu ce 3 3 de 4 2 ee 5 2 fe 5 3 -- - - u=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_REGISTER_HIGH_PC
          case 1:
            userStackPointer = (userStackPointer & 0x00FF) | (fetch(programCounter++) << 8);
            break;

          // FETCH_REGISTER_LOW_PC (EXECUTE)
          case 2:
            userStackPointer = (userStackPointer & 0xFF00) | fetch(programCounter++);
            ld16Bit(userStackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // [207] ILLEGAL
      case 207:
        illegal();
        break;

      // SUBB DIRECT
      case 208: {
        // | D0 0208 | SUBB | DIRECT | 4 | 2 | uaaaa |
        // | subb c0 2 2 d0 3 2 e0 4 2 f0 4 3 -- - - b-=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = sub8Bit(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPB DIRECT
      case 209: {
        // | D1 0209 | CMPB | DIRECT | 4 | 2 | uaaaa |
        // | cmpb c1 2 2 d1 3 2 e1 4 2 f1 4 3 -- - - b-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            sub8Bit(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SBCB DIRECT
      case 210: {
        // | D2 0210 | SBCB | DIRECT | 4 | 2 | uaaaa |
        // | sbcb c2 2 2 d2 3 2 e2 4 2 f2 4 3 -- - - b-=m+c - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = sbc(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADDD DIRECT
      case 211: {
        // | D3 0211 | ADDD | DIRECT | 6 | 2 | -aaaa |
        // | Add to Double acc. | D=D+s
        // | addd c3 3 3 d3 4 2 e3 5 2 f3 5 3 -- - - d+=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_HIGH_EA
          case 3:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 4:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            setD(addd(getD(), inputDataLatch));
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ANDB DIRECT
      case 212: {
        // | D4 0212 | ANDB | DIRECT | 4 | 2 | -aa0- |
        // | andb c4 2 2 d4 3 2 e4 4 2 f4 4 3 -- - - b&=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = and(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BITB DIRECT
      case 213: {
        // | D5 0213 | BITB | DIRECT | 4 | 2 | -aa0- |
        // | bitb c5 2 2 d5 3 2 e5 4 2 f5 4 3 -- - - b&m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            and(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDB DIRECT
      case 214: {
        // | D6 0214 | LDB | DIRECT | 4 | 2 | -aa0- |
        // | ldb c6 2 2 d6 3 2 e6 4 2 f6 4 3 -- - - b=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = ld8Bit(inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STB DIRECT
      case 215: {
        // | D7 0215 | STB | DIRECT | 4 | 2 | -aa0- |
        // | stb -- - - d7 3 2 e7 4 2 f7 4 3 -- - - m=b - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // WRITE_REGISTER_EA (EXECUTE)
          case 3:
            write(effectiveAddress, (accumulatorB & 0xFF));
            st8Bit(accumulatorB);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // EORB DIRECT
      case 216: {
        // | D8 0216 | EORB | DIRECT | 4 | 2 | -aa0- |
        // | eorb c8 2 2 d8 3 2 e8 4 2 f8 4 3 -- - - b^=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = eor(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADCB DIRECT
      case 217: {
        // | D9 0217 | ADCB | DIRECT | 4 | 2 | aaaaa |
        // | adcb c9 2 2 d9 3 2 e9 4 2 f9 4 3 -- - - b+=m+c x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = adc(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ORB DIRECT
      case 218: {
        // | DA 0218 | ORB | DIRECT | 4 | 2 | -aa0- |
        // | orb ca 2 2 da 3 2 ea 4 2 fa 4 3 -- - - b|=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = or(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADDB DIRECT
      case 219: {
        // | DB 0219 | ADDB | DIRECT | 4 | 2 | aaaaa |
        // | addb cb 2 2 db 3 2 eb 4 2 fb 4 3 -- - - b+=m x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 3:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = add(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDD DIRECT
      case 220: {
        // | DC 0220 | LDD | DIRECT | 5 | 2 | -aa0- |
        // | Load Double acc. | D=s
        // | ldd cc 3 3 dc 4 2 ec 5 2 fc 5 3 -- - - d=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_REGISTER_HIGH_EA
          case 3:
            accumulatorA = fetch(effectiveAddress);
            break;

          // FETCH_REGISTER_LOW_EA (EXECUTE)
          case 4:
            accumulatorB = fetch(effectiveAddress + 1);
            ld16Bit(getD());
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STD DIRECT
      case 221: {
        // | DD 0221 | STD | DIRECT | 5 | 2 | -aa0- |
        // | Store Double acc. | D=a
        // | std -- - - dd 4 2 ed 5 2 fd 5 3 -- - - m=d - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // WRITE_REGISTER_HIGH_EA
          case 3:
            write(effectiveAddress, (getD() >> 8) & 0xFF);
            break;

          // WRITE_REGISTER_LOW_EA (EXECUTE)
          case 4:
            write(effectiveAddress + 1, (getD() & 0xFF));
            st16Bit(getD());
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDU DIRECT
      case 222: {
        // | DE 0222 | LDU | DIRECT | 5 | 2 | -aa0- |
        // | Load User stack ptr | U=s
        // | ldu ce 3 3 de 4 2 ee 5 2 fe 5 3 -- - - u=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_REGISTER_HIGH_EA
          case 3:
            userStackPointer = (userStackPointer & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_REGISTER_LOW_EA (EXECUTE)
          case 4:
            userStackPointer = (userStackPointer & 0xFF00) | fetch(effectiveAddress + 1);
            ld16Bit(userStackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STU DIRECT
      case 223: {
        // | DF 0223 | STU | DIRECT | 5 | 2 | -aa0- |
        // | Store User stack ptr | U=a
        // | stu -- - - df 4 2 ef 5 2 ff 5 3 -- - - u=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // WRITE_REGISTER_HIGH_EA
          case 3:
            write(effectiveAddress, (userStackPointer >> 8) & 0xFF);
            break;

          // WRITE_REGISTER_LOW_EA (EXECUTE)
          case 4:
            write(effectiveAddress + 1, (userStackPointer & 0xFF));
            st16Bit(userStackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SUBB INDEXED
      case 224: {
        // | E0 0224 | SUBB | INDEXED | 4 | 2 | uaaaa |
        // | subb c0 2 2 d0 3 2 e0 4 2 f0 4 3 -- - - b-=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = sub8Bit(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPB INDEXED
      case 225: {
        // | E1 0225 | CMPB | INDEXED | 4 | 2 | uaaaa |
        // | cmpb c1 2 2 d1 3 2 e1 4 2 f1 4 3 -- - - b-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            sub8Bit(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SBCB INDEXED
      case 226: {
        // | E2 0226 | SBCB | INDEXED | 4 | 2 | uaaaa |
        // | sbcb c2 2 2 d2 3 2 e2 4 2 f2 4 3 -- - - b-=m+c - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = sbc(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADDD INDEXED
      case 227: {
        // | E3 0227 | ADDD | INDEXED | 6 | 2 | -aaaa |
        // | Add to Double acc. | D=D+s
        // | addd c3 3 3 d3 4 2 e3 5 2 f3 5 3 -- - - d+=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_HIGH_EA
          case 2:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 3:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            setD(addd(getD(), inputDataLatch));
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ANDB INDEXED
      case 228: {
        // | E4 0228 | ANDB | INDEXED | 4 | 2 | -aa0- |
        // | andb c4 2 2 d4 3 2 e4 4 2 f4 4 3 -- - - b&=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = and(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BITB INDEXED
      case 229: {
        // | E5 0229 | BITB | INDEXED | 4 | 2 | -aa0- |
        // | bitb c5 2 2 d5 3 2 e5 4 2 f5 4 3 -- - - b&m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            and(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDB INDEXED
      case 230: {
        // | E6 0230 | LDB | INDEXED | 4 | 2 | -aa0- |
        // | ldb c6 2 2 d6 3 2 e6 4 2 f6 4 3 -- - - b=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = ld8Bit(inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STB INDEXED
      case 231: {
        // | E7 0231 | STB | INDEXED | 4 | 2 | -aa0- |
        // | stb -- - - d7 3 2 e7 4 2 f7 4 3 -- - - m=b - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // WRITE_REGISTER_EA (EXECUTE)
          case 2:
            write(effectiveAddress, (accumulatorB & 0xFF));
            st8Bit(accumulatorB);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // EORB INDEXED
      case 232: {
        // | E8 0232 | EORB | INDEXED | 4 | 2 | -aa0- |
        // | eorb c8 2 2 d8 3 2 e8 4 2 f8 4 3 -- - - b^=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = eor(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADCB INDEXED
      case 233: {
        // | E9 0233 | ADCB | INDEXED | 4 | 2 | aaaaa |
        // | adcb c9 2 2 d9 3 2 e9 4 2 f9 4 3 -- - - b+=m+c x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = adc(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ORB INDEXED
      case 234: {
        // | EA 0234 | ORB | INDEXED | 4 | 2 | -aa0- |
        // | orb ca 2 2 da 3 2 ea 4 2 fa 4 3 -- - - b|=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = or(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADDB INDEXED
      case 235: {
        // | EB 0235 | ADDB | INDEXED | 4 | 2 | aaaaa |
        // | addb cb 2 2 db 3 2 eb 4 2 fb 4 3 -- - - b+=m x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 2:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = add(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDD INDEXED
      case 236: {
        // | EC 0236 | LDD | INDEXED | 5 | 2 | -aa0- |
        // | Load Double acc. | D=s
        // | ldd cc 3 3 dc 4 2 ec 5 2 fc 5 3 -- - - d=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_REGISTER_HIGH_EA
          case 2:
            accumulatorA = fetch(effectiveAddress);
            break;

          // FETCH_REGISTER_LOW_EA (EXECUTE)
          case 3:
            accumulatorB = fetch(effectiveAddress + 1);
            ld16Bit(getD());
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STD INDEXED
      case 237: {
        // | ED 0237 | STD | INDEXED | 5 | 2 | -aa0- |
        // | Store Double acc. | D=a
        // | std -- - - dd 4 2 ed 5 2 fd 5 3 -- - - m=d - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // WRITE_REGISTER_HIGH_EA
          case 2:
            write(effectiveAddress, (getD() >> 8) & 0xFF);
            break;

          // WRITE_REGISTER_LOW_EA (EXECUTE)
          case 3:
            write(effectiveAddress + 1, (getD() & 0xFF));
            st16Bit(getD());
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDU INDEXED
      case 238: {
        // | EE 0238 | LDU | INDEXED | 5 | 2 | -aa0- |
        // | Load User stack ptr | U=s
        // | ldu ce 3 3 de 4 2 ee 5 2 fe 5 3 -- - - u=m - - x x 0 -
        switch (instructionCycleNum++) {
          // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

          // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_REGISTER_HIGH_EA
          case 2:
            userStackPointer = (userStackPointer & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_REGISTER_LOW_EA (EXECUTE)
          case 3:
            userStackPointer = (userStackPointer & 0xFF00) | fetch(effectiveAddress + 1);
            ld16Bit(userStackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STU INDEXED
      case 239: {
        // | EF 0239 | STU | INDEXED | 5 | 2 | -aa0- |
        // | Store User stack ptr | U=a
        // | stu -- - - df 4 2 ef 5 2 ff 5 3 -- - - u=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_POST_BYTE_PC
          case 1:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // WRITE_REGISTER_HIGH_EA
          case 2:
            write(effectiveAddress, (userStackPointer >> 8) & 0xFF);
            break;

          // WRITE_REGISTER_LOW_EA (EXECUTE)
          case 3:
            write(effectiveAddress + 1, (userStackPointer & 0xFF));
            st16Bit(userStackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SUBB EXTENDED
      case 240: {
        // | F0 0240 | SUBB | EXTENDED | 5 | 3 | uaaaa |
        // | subb c0 2 2 d0 3 2 e0 4 2 f0 4 3 -- - - b-=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = sub8Bit(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPB EXTENDED
      case 241: {
        // | F1 0241 | CMPB | EXTENDED | 5 | 3 | uaaaa |
        // | cmpb c1 2 2 d1 3 2 e1 4 2 f1 4 3 -- - - b-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            sub8Bit(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SBCB EXTENDED
      case 242: {
        // | F2 0242 | SBCB | EXTENDED | 5 | 3 | uaaaa |
        // | sbcb c2 2 2 d2 3 2 e2 4 2 f2 4 3 -- - - b-=m+c - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = sbc(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADDD EXTENDED
      case 243: {
        // | F3 0243 | ADDD | EXTENDED | 7 | 3 | -aaaa |
        // | Add to Double acc. | D=D+s
        // | addd c3 3 3 d3 4 2 e3 5 2 f3 5 3 -- - - d+=m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_HIGH_EA
          case 4:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 5:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 6:
            fetch(0xffff);
            setD(addd(getD(), inputDataLatch));
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ANDB EXTENDED
      case 244: {
        // | F4 0244 | ANDB | EXTENDED | 5 | 3 | -aa0- |
        // | andb c4 2 2 d4 3 2 e4 4 2 f4 4 3 -- - - b&=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = and(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // BITB EXTENDED
      case 245: {
        // | F5 0245 | BITB | EXTENDED | 5 | 3 | -aa0- |
        // | bitb c5 2 2 d5 3 2 e5 4 2 f5 4 3 -- - - b&m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            and(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDB EXTENDED
      case 246: {
        // | F6 0246 | LDB | EXTENDED | 5 | 3 | -aa0- |
        // | ldb c6 2 2 d6 3 2 e6 4 2 f6 4 3 -- - - b=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = ld8Bit(inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STB EXTENDED
      case 247: {
        // | F7 0247 | STB | EXTENDED | 5 | 3 | -aa0- |
        // | stb -- - - d7 3 2 e7 4 2 f7 4 3 -- - - m=b - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // WRITE_REGISTER_EA (EXECUTE)
          case 4:
            write(effectiveAddress, (accumulatorB & 0xFF));
            st8Bit(accumulatorB);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // EORB EXTENDED
      case 248: {
        // | F8 0248 | EORB | EXTENDED | 5 | 3 | -aa0- |
        // | eorb c8 2 2 d8 3 2 e8 4 2 f8 4 3 -- - - b^=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = eor(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADCB EXTENDED
      case 249: {
        // | F9 0249 | ADCB | EXTENDED | 5 | 3 | aaaaa |
        // | adcb c9 2 2 d9 3 2 e9 4 2 f9 4 3 -- - - b+=m+c x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = adc(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ORB EXTENDED
      case 250: {
        // | FA 0250 | ORB | EXTENDED | 5 | 3 | -aa0- |
        // | orb ca 2 2 da 3 2 ea 4 2 fa 4 3 -- - - b|=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = or(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ADDB EXTENDED
      case 251: {
        // | FB 0251 | ADDB | EXTENDED | 5 | 3 | aaaaa |
        // | addb cb 2 2 db 3 2 eb 4 2 fb 4 3 -- - - b+=m x - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_EA (EXECUTE)
          case 4:
            inputDataLatch = fetch(effectiveAddress);
            accumulatorB = add(accumulatorB, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDD EXTENDED
      case 252: {
        // | FC 0252 | LDD | EXTENDED | 6 | 3 | -aa0- |
        // | Load Double acc. | D=s
        // | ldd cc 3 3 dc 4 2 ec 5 2 fc 5 3 -- - - d=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_REGISTER_HIGH_EA
          case 4:
            accumulatorA = fetch(effectiveAddress);
            break;

          // FETCH_REGISTER_LOW_EA (EXECUTE)
          case 5:
            accumulatorB = fetch(effectiveAddress + 1);
            ld16Bit(getD());
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STD EXTENDED
      case 253: {
        // | FD 0253 | STD | EXTENDED | 6 | 3 | -aa0- |
        // | Store Double acc. | D=a
        // | std -- - - dd 4 2 ed 5 2 fd 5 3 -- - - m=d - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // WRITE_REGISTER_HIGH_EA
          case 4:
            write(effectiveAddress, accumulatorA);
            break;

          // WRITE_REGISTER_LOW_EA (EXECUTE)
          case 5:
            write(effectiveAddress + 1, accumulatorB);
            st16Bit(getD());
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDU EXTENDED
      case 254: {
        // | FE 0254 | LDU | EXTENDED | 6 | 3 | -aa0- |
        // | Load User stack ptr | U=s
        // | ldu ce 3 3 de 4 2 ee 5 2 fe 5 3 -- - - u=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_REGISTER_HIGH_EA
          case 4:
            userStackPointer = (userStackPointer & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_REGISTER_LOW_EA (EXECUTE)
          case 5:
            userStackPointer = (userStackPointer & 0xFF00) | fetch(effectiveAddress + 1);
            ld16Bit(userStackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STU EXTENDED
      case 255: {
        // | FF 0255 | STU | EXTENDED | 6 | 3 | -aa0- |
        // | Store User stack ptr | U=a
        // | stu -- - - df 4 2 ef 5 2 ff 5 3 -- - - u=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_ADDRESS_HIGH_PC
          case 1:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // WRITE_REGISTER_HIGH_EA
          case 4:
            write(effectiveAddress, (userStackPointer >> 8) & 0xFF);
            break;

          // WRITE_REGISTER_LOW_EA (EXECUTE)
          case 5:
            write((effectiveAddress + 1) & 0xFFFF, (userStackPointer & 0xFF));
            st16Bit(userStackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBRN RELATIVE
      case 4129: {
        // | 1021 4129 | LBRN | RELATIVE | 5(6) | 4 | ----- |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_OFFSET_HIGH_PC
          case 2:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 3:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 4:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            instructionCycleNum++;
            break;

          // _FETCH_IGNORE_FFFF (IF BRANCH TAKEN)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBHI RELATIVE
      case 4130: {
        // | 1022 4130 | LBHI | RELATIVE | 5(6) | 4 | ----- |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_OFFSET_HIGH_PC
          case 2:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 3:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 4:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (!(carryFlag || zeroFlag)) {
              programCounter = effectiveAddress;
            } else {
              instructionCycleNum++;
            }
            break;

          // _FETCH_IGNORE_FFFF (IF BRANCH TAKEN)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBLS RELATIVE
      case 4131: {
        // | 1023 4131 | LBLS | RELATIVE | 5(6) | 4 | ----- |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_OFFSET_HIGH_PC
          case 2:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 3:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 4:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (carryFlag || zeroFlag) {
              programCounter = effectiveAddress;
            } else {
              instructionCycleNum++;
            }
            break;

          // _FETCH_IGNORE_FFFF (IF BRANCH TAKEN)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBCC RELATIVE
      case 4132: {
        // | 1024 4132 | LBHS/LBCC | RELATIVE | 5(6) | 4 | ----- |
        // | Long cond. Branch(~=6) | If cc LBRA
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_OFFSET_HIGH_PC
          case 2:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 3:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 4:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (!carryFlag) {
              programCounter = effectiveAddress;
            } else {
              instructionCycleNum++;
            }
            break;

          // _FETCH_IGNORE_FFFF (IF BRANCH TAKEN)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBCS RELATIVE
      case 4133: {
        // | 1025 4133 | LBLO/LBCS | RELATIVE | 5(6) | 4 | ----- |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_OFFSET_HIGH_PC
          case 2:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 3:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 4:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (carryFlag) {
              programCounter = effectiveAddress;
            } else {
              instructionCycleNum++;
            }
            break;

          // _FETCH_IGNORE_FFFF (IF BRANCH TAKEN)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBNE RELATIVE
      case 4134: {
        // | 1026 4134 | LBNE | RELATIVE | 5(6) | 4 | ----- |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_OFFSET_HIGH_PC
          case 2:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 3:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 4:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (!zeroFlag) {
              programCounter = effectiveAddress;
            } else {
              instructionCycleNum++;
            }
            break;

          // _FETCH_IGNORE_FFFF (IF BRANCH TAKEN)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBEQ RELATIVE
      case 4135: {
        // | 1027 4135 | LBEQ | RELATIVE | 5(6) | 4 | ----- |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_OFFSET_HIGH_PC
          case 2:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 3:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 4:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (zeroFlag) {
              programCounter = effectiveAddress;
            } else {
              instructionCycleNum++;
            }
            break;

          // _FETCH_IGNORE_FFFF (IF BRANCH TAKEN)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBVC RELATIVE
      case 4136: {
        // | 1028 4136 | LBVC | RELATIVE | 5(6) | 4 | ----- |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_OFFSET_HIGH_PC
          case 2:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 3:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 4:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (!overflowFlag) {
              programCounter = effectiveAddress;
            } else {
              instructionCycleNum++;
            }
            break;

          // _FETCH_IGNORE_FFFF (IF BRANCH TAKEN)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBVS RELATIVE
      case 4137: {
        // | 1029 4137 | LBVS | RELATIVE | 5(6) | 4 | ----- |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_OFFSET_HIGH_PC
          case 2:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 3:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 4:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (overflowFlag) {
              programCounter = effectiveAddress;
            } else {
              instructionCycleNum++;
            }
            break;

          // _FETCH_IGNORE_FFFF (IF BRANCH TAKEN)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBPL RELATIVE
      case 4138: {
        // | 102A 4138 | LBPL | RELATIVE | 5(6) | 4 | ----- |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_OFFSET_HIGH_PC
          case 2:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 3:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 4:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (!negativeFlag) {
              programCounter = effectiveAddress;
            } else {
              instructionCycleNum++;
            }
            break;

          // _FETCH_IGNORE_FFFF (IF BRANCH TAKEN)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBMI RELATIVE
      case 4139: {
        // | 102B 4139 | LBMI | RELATIVE | 5(6) | 4 | ----- |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_OFFSET_HIGH_PC
          case 2:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 3:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 4:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (negativeFlag) {
              programCounter = effectiveAddress;
            } else {
              instructionCycleNum++;
            }
            break;

          // _FETCH_IGNORE_FFFF (IF BRANCH TAKEN)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBGE RELATIVE
      case 4140: {
        // | 102C 4140 | LBGE | RELATIVE | 5(6) | 4 | ----- |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_OFFSET_HIGH_PC
          case 2:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 3:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 4:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (!(negativeFlag ^ overflowFlag)) {
              programCounter = effectiveAddress;
            } else {
              instructionCycleNum++;
            }
            break;

          // _FETCH_IGNORE_FFFF (IF BRANCH TAKEN)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBLT RELATIVE
      case 4141: {
        // | 102D 4141 | LBLT | RELATIVE | 5(6) | 4 | ----- |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_OFFSET_HIGH_PC
          case 2:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 3:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 4:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (negativeFlag ^ overflowFlag) {
              programCounter = effectiveAddress;
            } else {
              instructionCycleNum++;
            }
            break;

          // _FETCH_IGNORE_FFFF (IF BRANCH TAKEN)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBGT RELATIVE
      case 4142: {
        // | 102E 4142 | LBGT | RELATIVE | 5(6) | 4 | ----- |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_OFFSET_HIGH_PC
          case 2:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 3:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 4:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (!(zeroFlag || (negativeFlag ^ overflowFlag))) {
              programCounter = effectiveAddress;
            } else {
              instructionCycleNum++;
            }
            break;

          // _FETCH_IGNORE_FFFF (IF BRANCH TAKEN)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LBLE RELATIVE
      case 4143: {
        // | 102F 4143 | LBLE | RELATIVE | 5(6) | 4 | ----- |
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_OFFSET_HIGH_PC
          case 2:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 3:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA) (EXECUTE)
          case 4:
            fetch(0xffff);
            effectiveAddress = (programCounter + offset) & 0xFFFF;
            if (zeroFlag || (negativeFlag ^ overflowFlag)) {
              programCounter = effectiveAddress;
            } else {
              instructionCycleNum++;
            }
            break;

          // _FETCH_IGNORE_FFFF (IF BRANCH TAKEN)
          case 5:
            fetch(0xffff);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SWI2 INHERENT
      case 4159: {
        // | 103F 4159 | SWI2 | INHERENT | 20 | 2 | ----- |
        // | Software Interrupt 2 | SWI (10H)
        // | swi2 -- - - -- - - -- - - -- - - 103f ? 2 swi - 1 - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_IGNORE_PC
          case 2:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            entireFlag = true;
            break;

          // WRITE_PC_LOW_SP
          case 4:
            write(--stackPointer, (programCounter & 0xff));
            break;

          // WRITE_PC_HIGH_SP
          case 5:
            write(--stackPointer, (programCounter >> 8) & 0xff);
            break;

          // WRITE_USER_STACK_LOW_SP
          case 6:
            write(--stackPointer, (userStackPointer & 0xff));
            break;

          // WRITE_USER_STACK_HIGH_SP
          case 7:
            write(--stackPointer, (userStackPointer >> 8) & 0xff);
            break;

          // WRITE_Y_REGISTER_LOW_SP
          case 8:
            write(--stackPointer, (indexRegisterY & 0xff));
            break;

          // WRITE_Y_REGISTER_HIGH_SP
          case 9:
            write(--stackPointer, (indexRegisterY >> 8) & 0xff);
            break;

          // WRITE_X_REGISTER_LOW_SP
          case 10:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_X_REGISTER_HIGH_SP
          case 11:
            write(--stackPointer, (indexRegisterX >> 8) & 0xff);
            break;

          // WRITE_DP_REGISTER_SP
          case 12:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_B_REGISTER_SP
          case 13:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_A_REGISTER_SP
          case 14:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_CC_REGISTER_SP
          case 15:
            write(--stackPointer, (getCC() & 0xff));
            break;

          // FETCH_IGNORE_FFFF
          case 16:
            fetch(0xffff);
            break;

          // FETCH_INT_VECTOR_HIGH_FFF4
          case 17:
            effectiveAddress = (fetch(SWI2_VECTOR_HI) << 8);
            break;

          // FETCH_INT_VECTOR_LOW_FFF5
          case 18:
            effectiveAddress = (effectiveAddress & 0xFF00) | fetch(SWI2_VECTOR_LO);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 19:
            fetch(0xffff);
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPD IMMEDIATE
      case 4227: {
        // | 1083 4227 | CMPD | IMMEDIATE | 5 | 4 | -aaaa |
        // | Compare Double acc. | D-s (10H)
        // | cmpd 1083 5 4 1093 7 3 10a3 7 3 10b3 8 4 -- - - d-m - x x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_DATA_HIGH_PC
          case 2:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(programCounter++) << 8);
            break;

          // FETCH_DATA_LOW_PC
          case 3:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            sub16Bit(getD(), inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPY IMMEDIATE
      case 4236: {
        // | 108C 4236 | CMPY | IMMEDIATE | 5 | 4 | -aaaa |
        // | cmpy 108c 3 3 109c 4 2 10ac 5 2 10bc 5 3 -- - - y-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_DATA_HIGH_PC
          case 2:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(programCounter++) << 8);
            break;

          // FETCH_DATA_LOW_PC
          case 3:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            sub16Bit(indexRegisterY, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDY IMMEDIATE
      case 4238: {
        // | 108E 4238 | LDY | IMMEDIATE | 4 | 4 | -aa0- |
        // | ldy 108e 3 3 109e 4 2 10ae 5 2 10be 5 3 -- - - y=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_REGISTER_HIGH_PC
          case 2:
            indexRegisterY = (indexRegisterY & 0x00FF) | (fetch(programCounter++) << 8);
            break;

          // FETCH_REGISTER_LOW_PC (EXECUTE)
          case 3:
            indexRegisterY = (indexRegisterY & 0xFF00) | fetch(programCounter++);
            ld16Bit(indexRegisterY);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPD DIRECT
      case 4243: {
        // | 1093 4243 | CMPD | DIRECT | 7 | 3 | -aaaa |
        // | Compare Double acc. | D-s (10H)
        // | cmpd 1083 5 4 1093 7 3 10a3 7 3 10b3 8 4 -- - - d-m - x x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_HIGH_EA
          case 4:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 5:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 6:
            fetch(0xffff);
            sub16Bit(getD(), inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPY DIRECT
      case 4252: {
        // | 109C 4252 | CMPY | DIRECT | 7 | 3 | -aaaa |
        // | cmpy 108c 3 3 109c 4 2 10ac 5 2 10bc 5 3 -- - - y-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_HIGH_EA
          case 4:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 5:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 6:
            fetch(0xffff);
            sub16Bit(indexRegisterY, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDY DIRECT
      case 4254: {
        // | 109E 4254 | LDY | DIRECT | 6 | 3 | -aa0- |
        // | ldy 108e 3 3 109e 4 2 10ae 5 2 10be 5 3 -- - - y=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_REGISTER_HIGH_EA
          case 4:
            indexRegisterY = (indexRegisterY & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_REGISTER_LOW_EA (EXECUTE)
          case 5:
            indexRegisterY = (indexRegisterY & 0xFF00) | fetch(effectiveAddress + 1);
            ld16Bit(indexRegisterY);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STY DIRECT
      case 4255: {
        // | 109F 4255 | STY | DIRECT | 6 | 3 | -aa0- |
        // | sty -- - - 109f 4 2 10af 5 2 10bf 5 3 -- - - y=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // WRITE_REGISTER_HIGH_EA
          case 4:
            write(effectiveAddress, (indexRegisterY >> 8) & 0xFF);
            break;

          // WRITE_REGISTER_LOW_EA (EXECUTE)
          case 5:
            write(effectiveAddress + 1, (indexRegisterY & 0xFF));
            st16Bit(indexRegisterY);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPD INDEXED
      case 4259: {
        // | 10A3 4259 | CMPD | INDEXED | 7 | 3 | -aaaa |
        // | Compare Double acc. | D-s (10H)
        // | cmpd 1083 5 4 1093 7 3 10a3 7 3 10b3 8 4 -- - - d-m - x x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_POST_BYTE_PC
          case 2:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_HIGH_EA
          case 3:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 4:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            sub16Bit(getD(), inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPY INDEXED
      case 4268: {
        // | 10AC 4268 | CMPY | INDEXED | 7 | 3 | -aaaa |
        // | cmpy 108c 3 3 109c 4 2 10ac 5 2 10bc 5 3 -- - - y-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_POST_BYTE_PC
          case 2:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_HIGH_EA
          case 3:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 4:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            sub16Bit(indexRegisterY, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDY INDEXED
      case 4270: {
        // | 10AE 4270 | LDY | INDEXED | 6 | 3 | -aa0- |
        // | ldy 108e 3 3 109e 4 2 10ae 5 2 10be 5 3 -- - - y=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_POST_BYTE_PC
          case 2:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_REGISTER_HIGH_EA
          case 3:
            indexRegisterY = (indexRegisterY & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_REGISTER_LOW_EA (EXECUTE)
          case 4:
            indexRegisterY = (indexRegisterY & 0xFF00) | fetch(effectiveAddress + 1);
            ld16Bit(indexRegisterY);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STY INDEXED
      case 4271: {
        // | 10AF 4271 | STY | INDEXED | 6 | 3 | -aa0- |
        // | sty -- - - 109f 4 2 10af 5 2 10bf 5 3 -- - - y=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_POST_BYTE_PC
          case 2:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // WRITE_REGISTER_HIGH_EA
          case 3:
            write(effectiveAddress, (indexRegisterY >> 8) & 0xFF);
            break;

          // WRITE_REGISTER_LOW_EA (EXECUTE)
          case 4:
            write(effectiveAddress + 1, (indexRegisterY & 0xFF));
            st16Bit(indexRegisterY);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPD EXTENDED
      case 4275: {
        // | 10B3 4275 | CMPD | EXTENDED | 8 | 4 | -aaaa |
        // | Compare Double acc. | D-s (10H)
        // | cmpd 1083 5 4 1093 7 3 10a3 7 3 10b3 8 4 -- - - d-m - x x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_HIGH_PC
          case 2:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 3:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 4:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_HIGH_EA
          case 5:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 6:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 7:
            fetch(0xffff);
            sub16Bit(getD(), inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPY EXTENDED
      case 4284: {
        // | 10BC 4284 | CMPY | EXTENDED | 8 | 4 | -aaaa |
        // | cmpy 108c 3 3 109c 4 2 10ac 5 2 10bc 5 3 -- - - y-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_HIGH_PC
          case 2:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 3:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 4:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_HIGH_EA
          case 5:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 6:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 7:
            fetch(0xffff);
            sub16Bit(indexRegisterY, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDY EXTENDED
      case 4286: {
        // | 10BE 4286 | LDY | EXTENDED | 7 | 4 | -aa0- |
        // | ldy 108e 3 3 109e 4 2 10ae 5 2 10be 5 3 -- - - y=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_HIGH_PC
          case 2:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 3:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 4:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_REGISTER_HIGH_EA
          case 5:
            indexRegisterY = (indexRegisterY & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_REGISTER_LOW_EA (EXECUTE)
          case 6:
            indexRegisterY = (indexRegisterY & 0xFF00) | fetch(effectiveAddress + 1);
            ld16Bit(indexRegisterY);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STY EXTENDED
      case 4287: {
        // | 10BF 4287 | STY | EXTENDED | 7 | 4 | -aa0- |
        // | sty -- - - 109f 4 2 10af 5 2 10bf 5 3 -- - - y=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_HIGH_PC
          case 2:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 3:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 4:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // WRITE_REGISTER_HIGH_EA
          case 5:
            write(effectiveAddress, (indexRegisterY >> 8) & 0xFF);
            break;

          // WRITE_REGISTER_LOW_EA (EXECUTE)
          case 6:
            write(effectiveAddress + 1, (indexRegisterY & 0xFF));
            st16Bit(indexRegisterY);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDS IMMEDIATE
      case 4302: {
        // | 10CE 4302 | LDS | IMMEDIATE | 4 | 4 | -aa0- |
        // | Load Stack pointer | S=s (10H)
        // | lds 10ce 3 3 10de 4 2 10ee 5 2 10fe 5 3 -- - - s=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_REGISTER_HIGH_PC
          case 2:
            stackPointer = (stackPointer & 0x00FF) | (fetch(programCounter++) << 8);
            break;

          // FETCH_REGISTER_LOW_PC (EXECUTE)
          case 3:
            stackPointer = (stackPointer & 0xFF00) | fetch(programCounter++);
            nmiArmed = true;
            ld16Bit(stackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDS DIRECT
      case 4318: {
        // | 10DE 4318 | LDS | DIRECT | 6 | 3 | -aa0- |
        // | Load Stack pointer | S=s (10H)
        // | lds 10ce 3 3 10de 4 2 10ee 5 2 10fe 5 3 -- - - s=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_REGISTER_HIGH_EA
          case 4:
            stackPointer = (stackPointer & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_REGISTER_LOW_EA (EXECUTE)
          case 5:
            stackPointer = (stackPointer & 0xFF00) | fetch(effectiveAddress + 1);
            nmiArmed = true;
            ld16Bit(stackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STS DIRECT
      case 4319: {
        // | 10DF 4319 | STS | DIRECT | 6 | 3 | -aa0- |
        // | Store Stack pointer | S=a (10H)
        // | sts -- - - 10df 4 2 10ef 5 2 10ff 5 3 -- - - s=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // WRITE_REGISTER_HIGH_EA
          case 4:
            write(effectiveAddress, (stackPointer >> 8) & 0xFF);
            break;

          // WRITE_REGISTER_LOW_EA (EXECUTE)
          case 5:
            write(effectiveAddress + 1, (stackPointer & 0xFF));
            st16Bit(stackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDS INDEXED
      case 4334: {
        // | 10EE 4334 | LDS | INDEXED | 6 | 3 | -aa0- |
        // | Load Stack pointer | S=s (10H)
        // | lds 10ce 3 3 10de 4 2 10ee 5 2 10fe 5 3 -- - - s=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_POST_BYTE_PC
          case 2:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_REGISTER_HIGH_EA
          case 3:
            stackPointer = (stackPointer & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_REGISTER_LOW_EA (EXECUTE)
          case 4:
            stackPointer = (stackPointer & 0xFF00) | fetch(effectiveAddress + 1);
            nmiArmed = true;
            ld16Bit(stackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STS INDEXED
      case 4335: {
        // | 10EF 4335 | STS | INDEXED | 6 | 3 | -aa0- |
        // | Store Stack pointer | S=a (10H)
        // | sts -- - - 10df 4 2 10ef 5 2 10ff 5 3 -- - - s=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_POST_BYTE_PC
          case 2:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // WRITE_REGISTER_HIGH_EA
          case 3:
            write(effectiveAddress, (stackPointer >> 8) & 0xFF);
            break;

          // WRITE_REGISTER_LOW_EA (EXECUTE)
          case 4:
            write(effectiveAddress + 1, (stackPointer & 0xFF));
            st16Bit(stackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // LDS EXTENDED
      case 4350: {
        // | 10FE 4350 | LDS | EXTENDED | 7 | 4 | -aa0- |
        // | Load Stack pointer | S=s (10H)
        // | lds 10ce 3 3 10de 4 2 10ee 5 2 10fe 5 3 -- - - s=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_HIGH_PC
          case 2:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 3:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 4:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_REGISTER_HIGH_EA
          case 5:
            stackPointer = (stackPointer & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_REGISTER_LOW_EA (EXECUTE)
          case 6:
            stackPointer = (stackPointer & 0xFF00) | fetch(effectiveAddress + 1);
            nmiArmed = true;
            ld16Bit(stackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // STS EXTENDED
      case 4351: {
        // | 10FF 4351 | STS | EXTENDED | 7 | 4 | -aa0- |
        // | Store Stack pointer | S=a (10H)
        // | sts -- - - 10df 4 2 10ef 5 2 10ff 5 3 -- - - s=m - - x x 0 -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_HIGH_PC
          case 2:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 3:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 4:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // WRITE_REGISTER_HIGH_EA
          case 5:
            write(effectiveAddress, (stackPointer >> 8) & 0xFF);
            break;

          // WRITE_REGISTER_LOW_EA (EXECUTE)
          case 6:
            write(effectiveAddress + 1, (stackPointer & 0xFF));
            st16Bit(stackPointer);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // SWI3 INHERENT
      case 4415: {
        // | 113F 4415 | SWI3 | INHERENT | 20 | 2 | ----- |
        // | Software Interrupt 3 | SWI (11H)
        // | swi3 -- - - -- - - -- - - -- - - 113f ? 2 swi - 1 - - - -
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_IGNORE_PC
          case 2:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            entireFlag = true;
            break;

          // WRITE_PC_LOW_SP
          case 4:
            write(--stackPointer, (programCounter & 0xff));
            break;

          // WRITE_PC_HIGH_SP
          case 5:
            write(--stackPointer, (programCounter >> 8) & 0xff);
            break;

          // WRITE_USER_STACK_LOW_SP
          case 6:
            write(--stackPointer, (userStackPointer & 0xff));
            break;

          // WRITE_USER_STACK_HIGH_SP
          case 7:
            write(--stackPointer, (userStackPointer >> 8) & 0xff);
            break;

          // WRITE_Y_REGISTER_LOW_SP
          case 8:
            write(--stackPointer, (indexRegisterY & 0xff));
            break;

          // WRITE_Y_REGISTER_HIGH_SP
          case 9:
            write(--stackPointer, (indexRegisterY >> 8) & 0xff);
            break;

          // WRITE_X_REGISTER_LOW_SP
          case 10:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_X_REGISTER_HIGH_SP
          case 11:
            write(--stackPointer, (indexRegisterX >> 8) & 0xff);
            break;

          // WRITE_DP_REGISTER_SP
          case 12:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_B_REGISTER_SP
          case 13:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_A_REGISTER_SP
          case 14:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_CC_REGISTER_SP
          case 15:
            write(--stackPointer, (getCC() & 0xff));
            break;

          // FETCH_IGNORE_FFFF
          case 16:
            fetch(0xffff);
            break;

          // FETCH_INT_VECTOR_HIGH_FFF2
          case 17:
            effectiveAddress = (fetch(SWI3_VECTOR_HI) << 8);
            break;

          // FETCH_INT_VECTOR_LOW_FFF3
          case 18:
            effectiveAddress = (effectiveAddress & 0xFF00) | fetch(SWI3_VECTOR_LO);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 19:
            fetch(0xffff);
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPU IMMEDIATE
      case 4483: {
        // | 1183 4438 | CMPU | IMMEDIATE | 5 | 4 | -aaaa |
        // | Compare User stack ptr | U-s (11H)
        // | cmpu 1183 5 4 1193 7 3 11a3 7 3 11b3 8 4 -- - - u-m - x x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_DATA_HIGH_PC
          case 2:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(programCounter++) << 8);
            break;

          // FETCH_DATA_LOW_PC
          case 3:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            sub16Bit(userStackPointer, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPS IMMEDIATE
      case 4492: {
        // | 118C 4492 | CMPS | IMMEDIATE | 5 | 4 | -aaaa |
        // | Compare Stack pointer | S-s (11H)
        // | cmps 118c 3 3 119c 4 2 11ac 5 2 11bc 5 3 -- - - d-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_DATA_HIGH_PC
          case 2:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(programCounter++) << 8);
            break;

          // FETCH_DATA_LOW_PC
          case 3:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 4:
            fetch(0xffff);
            sub16Bit(stackPointer, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPU DIRECT
      case 4499: {
        // | 1193 4499 | CMPU | DIRECT | 7 | 3 | -aaaa |
        // | Compare User stack ptr | U-s (11H)
        // | cmpu 1183 5 4 1193 7 3 11a3 7 3 11b3 8 4 -- - - u-m - x x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_HIGH_EA
          case 4:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 5:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 6:
            fetch(0xffff);
            sub16Bit(userStackPointer, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPS DIRECT
      case 4508: {
        // | 119C 4508 | CMPS | DIRECT | 7 | 3 | -aaaa |
        // | Compare Stack pointer | S-s (11H)
        // | cmps 118c 3 3 119c 4 2 11ac 5 2 11bc 5 3 -- - - d-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_LOW_PC
          case 2:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (directPageRegister << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_HIGH_EA
          case 4:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 5:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 6:
            fetch(0xffff);
            sub16Bit(stackPointer, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPU INDEXED
      case 4515: {
        // | 11A3 4515 | CMPU | INDEXED | 7 | 3 | -aaaa |
        // | Compare User stack ptr | U-s (11H)
        // | cmpu 1183 5 4 1193 7 3 11a3 7 3 11b3 8 4 -- - - u-m - x x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_POST_BYTE_PC
          case 2:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_HIGH_EA
          case 3:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 4:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            sub16Bit(userStackPointer, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPS INDEXED
      case 4524: {
        // | 11AC 4524 | CMPS | INDEXED | 7 | 3 | -aaaa |
        // | Compare Stack pointer | S-s (11H)
        // | cmps 118c 3 3 119c 4 2 11ac 5 2 11bc 5 3 -- - - d-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_POST_BYTE_PC
          case 2:
            postByte = fetch(programCounter++);

            // BASED_ON_INDEX_MODE
            instructionRegister = indexModeSteps(postByte);
            break;

          // FETCH_DATA_HIGH_EA
          case 3:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 4:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 5:
            fetch(0xffff);
            sub16Bit(stackPointer, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPU EXTENDED
      case 4531: {
        // | 11B3 4531 | CMPU | EXTENDED | 8 | 4 | -aaaa |
        // | Compare User stack ptr | U-s (11H)
        // | cmpu 1183 5 4 1193 7 3 11a3 7 3 11b3 8 4 -- - - u-m - x x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_HIGH_PC
          case 2:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 3:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 4:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_HIGH_EA
          case 5:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 6:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 7:
            fetch(0xffff);
            sub16Bit(userStackPointer, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // CMPS EXTENDED
      case 4540: {
        // | 11BC 4540 | CMPS | EXTENDED | 8 | 4 | -aaaa |
        // | Compare Stack pointer | S-s (11H)
        // | cmps 118c 3 3 119c 4 2 11ac 5 2 11bc 5 3 -- - - d-m - - x x x x
        switch (instructionCycleNum++) {
        // FETCH_OPCODE_PC
          case 0:
            // Opcode already fetched in the default case of the previous
            // instruction.

            // FETCH_OPCODE_2ND_BYTE_PC
          case 1:
            // Already fetched by 0x10/0x11 instruction case.
            break;

          // FETCH_ADDRESS_HIGH_PC
          case 2:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 3:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 4:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            break;

          // FETCH_DATA_HIGH_EA
          case 5:
            inputDataLatch = (inputDataLatch & 0x00FF) | (fetch(effectiveAddress) << 8);
            break;

          // FETCH_DATA_LOW_EA
          case 6:
            inputDataLatch = (inputDataLatch & 0xFF00) | fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 7:
            fetch(0xffff);
            sub16Bit(stackPointer, inputDataLatch);
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // ,R+ INDEX
      case 4608: {
        switch (instructionCycleNum++) {
        // FETCH_IGNORE_PC
          case 0:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 1:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            effectiveAddress = indexedAddressModeRegister;
            indexedAddressModeRegister = (indexedAddressModeRegister + 1) & 0xFFFF;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            int registerNum = (postByte & 0x60) >>> 5;
            if (registerNum == 0) {
              indexRegisterX = indexedAddressModeRegister;
            } else if (registerNum == 1) {
              indexRegisterY = indexedAddressModeRegister;
            } else if (registerNum == 2) {
              userStackPointer = indexedAddressModeRegister;
            } else {
              stackPointer = indexedAddressModeRegister;
            }
            break;

        }
        break;
      }

      // ,R++ INDEX
      case 4609: {
        switch (instructionCycleNum++) {
        // FETCH_IGNORE_PC
          case 0:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 1:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = indexedAddressModeRegister;
            indexedAddressModeRegister = (indexedAddressModeRegister + 2) & 0xFFFF;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            int registerNum = (postByte & 0x60) >>> 5;
            if (registerNum == 0) {
              indexRegisterX = indexedAddressModeRegister;
            } else if (registerNum == 1) {
              indexRegisterY = indexedAddressModeRegister;
            } else if (registerNum == 2) {
              userStackPointer = indexedAddressModeRegister;
            } else {
              stackPointer = indexedAddressModeRegister;
            }
            break;

        }
        break;
      }

      // ,-R INDEX
      case 4610: {
        switch (instructionCycleNum++) {
        // FETCH_IGNORE_PC
          case 0:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 1:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 2:
            fetch(0xffff);
            indexedAddressModeRegister = (indexedAddressModeRegister - 1) & 0xFFFF;
            effectiveAddress = indexedAddressModeRegister;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            int registerNum = (postByte & 0x60) >>> 5;
            if (registerNum == 0) {
              indexRegisterX = indexedAddressModeRegister;
            } else if (registerNum == 1) {
              indexRegisterY = indexedAddressModeRegister;
            } else if (registerNum == 2) {
              userStackPointer = indexedAddressModeRegister;
            } else {
              stackPointer = indexedAddressModeRegister;
            }
            break;

        }
        break;
      }

      // ,--R INDEX
      case 4611: {
        switch (instructionCycleNum++) {
        // FETCH_IGNORE_PC
          case 0:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 1:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            indexedAddressModeRegister = (indexedAddressModeRegister - 2) & 0xFFFF;
            effectiveAddress = indexedAddressModeRegister;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            int registerNum = (postByte & 0x60) >>> 5;
            if (registerNum == 0) {
              indexRegisterX = indexedAddressModeRegister;
            } else if (registerNum == 1) {
              indexRegisterY = indexedAddressModeRegister;
            } else if (registerNum == 2) {
              userStackPointer = indexedAddressModeRegister;
            } else {
              stackPointer = indexedAddressModeRegister;
            }
            break;

        }
        break;
      }

      // ,R INDEX
      case 4612: {
        switch (instructionCycleNum++) {
        // FETCH_IGNORE_PC (CALCULATE EA)
          case 0:
            effectiveAddress = indexedAddressModeRegister;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // B,R INDEX
      case 4613: {
        switch (instructionCycleNum++) {
        // FETCH_IGNORE_PC
          case 0:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 1:
            fetch(0xffff);
            effectiveAddress = (indexedAddressModeRegister + to2C8Bit(accumulatorB)) & 0xFFFF;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // A,R INDEX
      case 4614: {
        switch (instructionCycleNum++) {
        // FETCH_IGNORE_PC
          case 0:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 1:
            fetch(0xffff);
            effectiveAddress = (indexedAddressModeRegister + to2C8Bit(accumulatorA)) & 0xFFFF;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // 8n,R INDEX
      case 4616: {
        switch (instructionCycleNum++) {
        // FETCH_OFFSET_PC
          case 0:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 1:
            fetch(0xffff);
            effectiveAddress = (indexedAddressModeRegister + to2C8Bit(offset)) & 0xFFFF;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // 16n,R INDEX
      case 4617: {
        switch (instructionCycleNum++) {
        // FETCH_OFFSET_HIGH_PC
          case 0:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 1:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_PC
          case 2:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 4:
            fetch(0xffff);
            effectiveAddress = (indexedAddressModeRegister + to2C16Bit(offset)) & 0xFFFF;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // D,R INDEX
      case 4619: {
        switch (instructionCycleNum++) {
        // FETCH_IGNORE_PC
          case 0:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_PC
          case 1:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_PC
          case 2:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 4:
            fetch(0xffff);
            effectiveAddress = (indexedAddressModeRegister + to2C16Bit(getD())) & 0xFFFF;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // 8n,PC INDEX
      case 4620: {
        switch (instructionCycleNum++) {
        // FETCH_OFFSET_PC
          case 0:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 1:
            fetch(0xffff);
            effectiveAddress = (programCounter + to2C8Bit(offset)) & 0xFFFF;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // 16n,PC INDEX
      case 4621: {
        switch (instructionCycleNum++) {
        // FETCH_OFFSET_HIGH_PC
          case 0:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 1:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_PC
          case 2:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 4:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 5:
            fetch(0xffff);
            effectiveAddress = (programCounter + to2C16Bit(offset)) & 0xFFFF;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // [,R++] INDEX
      case 4625: {
        switch (instructionCycleNum++) {
        // FETCH_IGNORE_PC
          case 0:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 1:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // FETCH_INDIRECT_HIGH_IX
          case 4:
            effectiveAddress = indexedAddressModeRegister;
            indexedAddressModeRegister = (indexedAddressModeRegister + 2) & 0xFFFF;
            effectiveAddressHigh = fetch(effectiveAddress);
            break;

          // FETCH_INDIRECT_LOW_IX
          case 5:
            effectiveAddressLow = fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 6:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            int registerNum = (postByte & 0x60) >>> 5;
            if (registerNum == 0) {
              indexRegisterX = indexedAddressModeRegister;
            } else if (registerNum == 1) {
              indexRegisterY = indexedAddressModeRegister;
            } else if (registerNum == 2) {
              userStackPointer = indexedAddressModeRegister;
            } else {
              stackPointer = indexedAddressModeRegister;
            }
            break;

        }
        break;
      }

      // [,--R] INDEX
      case 4627: {
        switch (instructionCycleNum++) {
        // FETCH_IGNORE_PC
          case 0:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 1:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // FETCH_INDIRECT_HIGH_IX
          case 4:
            indexedAddressModeRegister = (indexedAddressModeRegister - 2) & 0xFFFF;
            effectiveAddress = indexedAddressModeRegister;
            effectiveAddressHigh = fetch(effectiveAddress);
            break;

          // FETCH_INDIRECT_LOW_IX
          case 5:
            effectiveAddressLow = fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 6:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            int registerNum = (postByte & 0x60) >>> 5;
            if (registerNum == 0) {
              indexRegisterX = indexedAddressModeRegister;
            } else if (registerNum == 1) {
              indexRegisterY = indexedAddressModeRegister;
            } else if (registerNum == 2) {
              userStackPointer = indexedAddressModeRegister;
            } else {
              stackPointer = indexedAddressModeRegister;
            }
            break;

        }
        break;
      }

      // [,R] INDEX
      case 4628: {
        switch (instructionCycleNum++) {
        // FETCH_IGNORE_PC
          case 0:
            fetch(programCounter);
            break;

          // FETCH_INDIRECT_HIGH_IX
          case 1:
            effectiveAddress = indexedAddressModeRegister;
            effectiveAddressHigh = fetch(effectiveAddress);
            break;

          // FETCH_INDIRECT_LOW_IX
          case 2:
            effectiveAddressLow = fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 3:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // [B,R] INDEX
      case 4629: {
        switch (instructionCycleNum++) {
        // FETCH_IGNORE_PC
          case 0:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 1:
            fetch(0xffff);
            break;

          // FETCH_INDIRECT_HIGH_IX
          case 2:
            effectiveAddress = (indexedAddressModeRegister + to2C8Bit(accumulatorB)) & 0xFFFF;
            effectiveAddressHigh = fetch(effectiveAddress);
            break;

          // FETCH_INDIRECT_LOW_IX
          case 3:
            effectiveAddressLow = fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 4:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // [A,R] INDEX
      case 4630: {
        switch (instructionCycleNum++) {
        // FETCH_IGNORE_PC
          case 0:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 1:
            fetch(0xffff);
            break;

          // FETCH_INDIRECT_HIGH_IX
          case 2:
            effectiveAddress = (indexedAddressModeRegister + to2C8Bit(accumulatorA)) & 0xFFFF;
            effectiveAddressHigh = fetch(effectiveAddress);
            break;

          // FETCH_INDIRECT_LOW_IX
          case 3:
            effectiveAddressLow = fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 4:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // [8n,R] INDEX
      case 4632: {
        switch (instructionCycleNum++) {
        // FETCH_OFFSET_PC
          case 0:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF
          case 1:
            fetch(0xffff);
            break;

          // FETCH_INDIRECT_HIGH_IX
          case 2:
            effectiveAddress = (indexedAddressModeRegister + to2C8Bit(offset)) & 0xFFFF;
            effectiveAddressHigh = fetch(effectiveAddress);
            break;

          // FETCH_INDIRECT_LOW_IX
          case 3:
            effectiveAddressLow = fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 4:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // [16n,R] INDEX
      case 4633: {
        switch (instructionCycleNum++) {
        // FETCH_OFFSET_HIGH_PC
          case 0:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 1:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_PC
          case 2:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 4:
            fetch(0xffff);
            break;

          // FETCH_INDIRECT_HIGH_IX
          case 5:
            effectiveAddress = (indexedAddressModeRegister + to2C16Bit(offset)) & 0xFFFF;
            effectiveAddressHigh = fetch(effectiveAddress);
            break;

          // FETCH_INDIRECT_LOW_IX
          case 6:
            effectiveAddressLow = fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 7:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // [D,R] INDEX
      case 4635: {
        switch (instructionCycleNum++) {
        // FETCH_IGNORE_PC
          case 0:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_PC
          case 1:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_PC
          case 2:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 4:
            fetch(0xffff);
            break;

          // FETCH_INDIRECT_HIGH_IX
          case 5:
            effectiveAddress = (indexedAddressModeRegister + to2C16Bit(getD())) & 0xFFFF;
            effectiveAddressHigh = fetch(effectiveAddress);
            break;

          // FETCH_INDIRECT_LOW_IX
          case 6:
            effectiveAddressLow = fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 7:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // [8n,PC] INDEX
      case 4636: {
        switch (instructionCycleNum++) {
        // FETCH_OFFSET_PC
          case 0:
            offset = to2C8Bit(fetch(programCounter++));
            break;

          // FETCH_IGNORE_FFFF
          case 1:
            fetch(0xffff);
            break;

          // FETCH_INDIRECT_HIGH_IX
          case 2:
            effectiveAddress = (programCounter + to2C8Bit(offset)) & 0xFFFF;
            effectiveAddressHigh = fetch(effectiveAddress);
            break;

          // FETCH_INDIRECT_LOW_IX
          case 3:
            effectiveAddressLow = fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 4:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // [16n,PC] INDEX
      case 4637: {
        switch (instructionCycleNum++) {
        // FETCH_OFFSET_HIGH_PC
          case 0:
            offset = to2C16Bit((offset & 0x00FF) | (fetch(programCounter++) << 8));
            break;

          // FETCH_OFFSET_LOW_PC
          case 1:
            offset = to2C16Bit((offset & 0xFF00) | fetch(programCounter++));
            break;

          // FETCH_IGNORE_PC
          case 2:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 3:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 4:
            fetch(0xffff);
            break;

          // FETCH_IGNORE_FFFF
          case 5:
            fetch(0xffff);
            break;

          // FETCH_INDIRECT_HIGH_IX
          case 6:
            effectiveAddress = (programCounter + to2C16Bit(offset)) & 0xFFFF;
            effectiveAddressHigh = fetch(effectiveAddress);
            break;

          // FETCH_INDIRECT_LOW_IX
          case 7:
            effectiveAddressLow = fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 8:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // [Addr] INDEX
      case 4639: {
        switch (instructionCycleNum++) {
        // FETCH_ADDRESS_HIGH_PC
          case 0:
            effectiveAddressHigh = fetch(programCounter++);
            break;

          // FETCH_ADDRESS_LOW_PC
          case 1:
            effectiveAddressLow = fetch(programCounter++);
            break;

          // FETCH_IGNORE_PC
          case 2:
            fetch(programCounter);
            break;

          // FETCH_INDIRECT_HIGH_IX
          case 3:
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            effectiveAddressHigh = fetch(effectiveAddress);
            break;

          // FETCH_INDIRECT_LOW_IX
          case 4:
            effectiveAddressLow = fetch(effectiveAddress + 1);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 5:
            fetch(0xffff);
            effectiveAddress = (effectiveAddressHigh << 8) | effectiveAddressLow;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // 5n,R INDEX
      case 4640: {
        switch (instructionCycleNum++) {
        // FETCH_IGNORE_PC
          case 0:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF (CALCULATE EA)
          case 1:
            fetch(0xffff);
            effectiveAddress = (indexedAddressModeRegister + to2C5Bit(postByte & 0x1f)) & 0xFFFF;
            instructionRegister = savedInstruction;
            instructionCycleNum = savedCycle;
            break;

        }
        break;
      }

      // FIRQ HARDWARE
      case FIRQ_INSTRUCTION: {
        switch (instructionCycleNum++) {
          // FETCH_PC
          case 0:
            // This cycle already happened with the fetch in the interruptOrFetch method.
            break;

          // FETCH_PC
          case 1:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            entireFlag = false;
            break;

          // WRITE_PC_LOW_SP
          case 3:
            write(--stackPointer, (programCounter & 0xff));
            break;

          // WRITE_PC_HIGH_SP
          case 4:
            write(--stackPointer, (programCounter >> 8) & 0xff);
            break;

          // WRITE_CC_REGISTER_SP
          case 5:
            write(--stackPointer, (getCC() & 0xff));
            break;

          // FETCH_IGNORE_FFFF
          case 6:
            fetch(0xffff);
            irqDisableFlag = true;
            firqDisableFlag = true;
            break;

          // FETCH_INT_VECTOR_HIGH_FFF6
          case 7:
            effectiveAddress = (fetch(FIRQ_VECTOR_HI) << 8);
            break;

          // FETCH_INT_VECTOR_LOW_FFF7
          case 8:
            effectiveAddress = (effectiveAddress & 0xFF00) | fetch(FIRQ_VECTOR_LO);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 9:
            fetch(0xffff);
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // IRQ HARDWARE
      case IRQ_INSTRUCTION: {
        switch (instructionCycleNum++) {
          // FETCH_PC
          case 0:
            // This cycle already happened with the fetch in the interruptOrFetch method.
            break;

          // FETCH_PC
          case 1:
            fetch(programCounter);
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            entireFlag = true;
            break;

          // WRITE_PC_LOW_SP
          case 3:
            write(--stackPointer, (programCounter & 0xff));
            break;

          // WRITE_PC_HIGH_SP
          case 4:
            write(--stackPointer, (programCounter >> 8) & 0xff);
            break;

          // WRITE_USER_STACK_LOW_SP
          case 5:
            write(--stackPointer, (userStackPointer & 0xff));
            break;

          // WRITE_USER_STACK_HIGH_SP
          case 6:
            write(--stackPointer, (userStackPointer >> 8) & 0xff);
            break;

          // WRITE_Y_REGISTER_LOW_SP
          case 7:
            write(--stackPointer, (indexRegisterY & 0xff));
            break;

          // WRITE_Y_REGISTER_HIGH_SP
          case 8:
            write(--stackPointer, (indexRegisterY >> 8) & 0xff);
            break;

          // WRITE_X_REGISTER_LOW_SP
          case 9:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_X_REGISTER_HIGH_SP
          case 10:
            write(--stackPointer, (indexRegisterX >> 8) & 0xff);
            break;

          // WRITE_DP_REGISTER_SP
          case 11:
            write(--stackPointer, (directPageRegister & 0xff));
            break;

          // WRITE_B_REGISTER_SP
          case 12:
            write(--stackPointer, (accumulatorB & 0xff));
            break;

          // WRITE_A_REGISTER_SP
          case 13:
            write(--stackPointer, (accumulatorA & 0xff));
            break;

          // WRITE_CC_REGISTER_SP
          case 14:
            write(--stackPointer, (getCC() & 0xff));
            break;

          // FETCH_IGNORE_FFFF
          case 15:
            fetch(0xffff);
            irqDisableFlag = true;
            break;

          // FETCH_INT_VECTOR_HIGH_FFF8
          case 16:
            effectiveAddress = (fetch(IRQ_VECTOR_HI) << 8);
            break;

          // FETCH_INT_VECTOR_LOW_FFF9
          case 17:
            effectiveAddress = (effectiveAddress & 0xFF00) | fetch(IRQ_VECTOR_LO);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 18:
            fetch(0xffff);
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // NMI HARDWARE
      case NMI_INSTRUCTION: {
        switch (instructionCycleNum++) {
          // FETCH_PC
          case 0:
            // This cycle already happened with the fetch in the interruptOrFetch method.
            break;

          // FETCH_PC
          case 1:
            fetch(programCounter);
            // NMI is automatically cleared. Actually, what really happens is that it is triggered on
            // a negative edge, which is different from IRQ and FIRQ, which trigger on a low level. So
            // the way we handle that is to clear the NMI state as soon as we've acknowledged it.
            interruptStatus &= ~S_NMI;
            break;

          // FETCH_IGNORE_FFFF
          case 2:
            fetch(0xffff);
            entireFlag = true;
            break;

          // WRITE_PC_LOW_SP
          case 3:
            write(--stackPointer, (programCounter & 0xff));
            break;

          // WRITE_PC_HIGH_SP
          case 4:
            write(--stackPointer, (programCounter >> 8) & 0xff);
            break;

          // WRITE_USER_STACK_LOW_SP
          case 5:
            write(--stackPointer, (userStackPointer & 0xff));
            break;

          // WRITE_USER_STACK_HIGH_SP
          case 6:
            write(--stackPointer, (userStackPointer >> 8) & 0xff);
            break;

          // WRITE_Y_REGISTER_LOW_SP
          case 7:
            write(--stackPointer, (indexRegisterY & 0xff));
            break;

          // WRITE_Y_REGISTER_HIGH_SP
          case 8:
            write(--stackPointer, (indexRegisterY >> 8) & 0xff);
            break;

          // WRITE_X_REGISTER_LOW_SP
          case 9:
            write(--stackPointer, (indexRegisterX & 0xff));
            break;

          // WRITE_X_REGISTER_HIGH_SP
          case 10:
            write(--stackPointer, (indexRegisterX >> 8) & 0xff);
            break;

          // WRITE_DP_REGISTER_SP
          case 11:
            write(--stackPointer, (directPageRegister & 0xff));
            break;

          // WRITE_B_REGISTER_SP
          case 12:
            write(--stackPointer, (accumulatorB & 0xff));
            break;

          // WRITE_A_REGISTER_SP
          case 13:
            write(--stackPointer, (accumulatorA & 0xff));
            break;

          // WRITE_CC_REGISTER_SP
          case 14:
            write(--stackPointer, (getCC() & 0xff));
            break;

          // FETCH_IGNORE_FFFF
          case 15:
            fetch(0xffff);
            irqDisableFlag = true;
            firqDisableFlag = true;
            break;

          // FETCH_INT_VECTOR_HIGH_FFFC
          case 16:
            effectiveAddress = (fetch(NMI_VECTOR_HI) << 8);
            break;

          // FETCH_INT_VECTOR_LOW_FFFD
          case 17:
            effectiveAddress = (effectiveAddress & 0xFF00) | fetch(NMI_VECTOR_LO);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 18:
            fetch(0xffff);
            programCounter = effectiveAddress;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // RESET HARDWARE
      case RESET_INSTRUCTION: {
        switch (instructionCycleNum++) {
        // DO

        // FETCH_IGNORE_FFFE
          case 0:
            fetch(0xfffe);

            // WHILE_RESET_LINE_IS_LOW
            if (!reset)
              instructionCycleNum = instructionCycleNum - 1;
            break;

          // FETCH_IGNORE_FFFE
          case 1:
            fetch(0xfffe);
            break;

          // FETCH_IGNORE_FFFE
          case 2:
            fetch(0xfffe);
            break;

          // FETCH_IGNORE_FFFE
          case 3:
            fetch(0xfffe);
            break;

          // FETCH_INT_VECTOR_HIGH_FFFE
          case 4:
            effectiveAddress = (fetch(RESET_VECTOR_HI) << 8);
            break;

          // FETCH_INT_VECTOR_LOW_FFFF
          case 5:
            effectiveAddress = (effectiveAddress & 0xFF00) | fetch(RESET_VECTOR_LO);
            break;

          // FETCH_IGNORE_FFFF (EXECUTE)
          case 6:
            fetch(0xffff);
            programCounter = effectiveAddress;
            reset = false;
            break;

          // FETCH_OPCODE_PC (NEXT INSTRUCTION)
          default:
            instructionRegister = interruptOrFetch();
            instructionCycleNum = 1;
            break;
        }
        break;
      }

      // END OF GENERATED CODE
      
      // If no instruction had previously been loaded, we start by loading one.
      default: {
        if (instructionRegister != NO_INSTRUCTION) illegal();
        instructionRegister = interruptOrFetch();
        instructionCycleNum = 1;
      }
    }
  }
  
  /**
   * Checks for interrupts, and if there is one, sets up the next set of instruction
   * cycles to execute the relevant interrupt. Otherwise if there is no interrupt waiting,
   * then look for the next actual instruction using the program counter. 
   * 
   * @return The next value for the instruction register.
   */
  private int interruptOrFetch() {
    // The opcode fetch using the PC happens regardless of whether there's an interrupt or 
    // not. It gets ignored if there is an interrupt.
    int instructionNum = fetch(programCounter);
    
    if (((interruptStatus & S_NMI) != 0) && nmiArmed) {
      instructionNum = NMI_INSTRUCTION;
    }
    else if (((interruptStatus & S_FIRQ) != 0) && !firqDisableFlag) {
      instructionNum = FIRQ_INSTRUCTION;
    }
    else if (((interruptStatus & S_IRQ) != 0) && !irqDisableFlag) {
      instructionNum = IRQ_INSTRUCTION;
    }
    else {
      // If there wasn't an interrupt, then we continue with the opcode we fetched and increment PC. 
      programCounter++;
    }
    
    return instructionNum;
  }

  private int indexModeSteps(int postbyte) {
    // Save where we are in the current instruction.
    savedInstruction = instructionRegister;
    savedCycle = instructionCycleNum;
    instructionCycleNum = 0;

    // Use postbyte to work out the register to include in EA calculation.
    int registerNum = (postbyte & 0x60) >>> 5;
    if (registerNum == 0) {
      indexedAddressModeRegister = indexRegisterX;
    } else if (registerNum == 1) {
      indexedAddressModeRegister = indexRegisterY;
    } else if (registerNum == 2) {
      indexedAddressModeRegister = userStackPointer;
    } else {
      indexedAddressModeRegister = stackPointer;
    }

    int indexInstructionNum = 0;
    if ((postbyte & 0x80) == 0) {
      // 5-bit offset.
      indexInstructionNum = 0x1220;
    } else {
      int lsn = (postbyte & 0x0f);
      boolean isIndirect = ((postbyte & 0x10) != 0);
      indexInstructionNum = 0x1200 + lsn + (isIndirect ? 0x10 : 0x00);
    }

    return indexInstructionNum;
  }

  public void write(int address, int data) {
    memoryMap[address].writeMemory(address, data);
  }

  public int fetch(int address) {
    return memoryMap[address].readMemory(address);
  }

  private int adc(int operand1, int operand2) {
    int cVal = carryFlag ? 1 : 0;
    int temp = (operand1 & 0x0f) + (operand2 & 0x0f) + cVal;
    halfCarryFlag = (temp & 0x10) != 0;
    temp = (operand1 & 0x7f) + (operand2 & 0x7f) + cVal;
    overflowFlag = (temp & 0x80) != 0;
    temp = (operand1 & 0xff) + (operand2 & 0xff) + cVal;
    carryFlag = (temp & 0x100) != 0;
    operand1 = (temp & 0xff);
    overflowFlag = overflowFlag ^ carryFlag;
    negativeFlag = ((operand1 & 0x80) != 0);
    zeroFlag = (operand1 == 0);
    return operand1;
  }

  private int add(int operand1, int operand2) {
    int temp = (operand1 & 0x0f) + (operand2 & 0x0f);
    halfCarryFlag = (temp & 0x10) != 0;
    temp = (operand1 & 0x7f) + (operand2 & 0x7f);
    overflowFlag = (temp & 0x80) != 0;
    temp = (operand1 & 0xff) + (operand2 & 0xff);
    carryFlag = (temp & 0x100) != 0;
    operand1 = temp & 0xff;
    overflowFlag = overflowFlag ^ carryFlag;
    negativeFlag = ((operand1 & 0x80) != 0);
    zeroFlag = operand1 == 0;
    return operand1;
  }

  private int addd(int operand1, int operand2) {
    int temp = (operand1 & 0x7fff) + (operand2 & 0x7fff);
    overflowFlag = ((temp & 0x8000) != 0);
    temp = (operand1 & 0xffff) + (operand2 & 0xffff);
    carryFlag = ((temp & 0x10000) != 0);
    overflowFlag = overflowFlag ^ carryFlag;
    operand1 = (temp & 0xffff);
    negativeFlag = ((operand1 & 0x8000) != 0);
    zeroFlag = (operand1 == 0);
    return operand1;
  }
  
  private int and(int operand1, int operand2) {
    operand1 = operand1 & operand2;
    overflowFlag = false;
    negativeFlag = ((operand1 & 0x80) != 0);
    zeroFlag = operand1 == 0;
    return operand1;
  }

  private int asl(int operand) {
    carryFlag = (operand & 0x80) != 0;
    overflowFlag = ((operand & 0x80) >> 7) != ((operand & 0x40) >> 6); // bit 7 xor bit 6
    operand = (operand << 1) & 0xff;
    negativeFlag = ((operand & 0x80) != 0);
    zeroFlag = operand == 0;
    return operand;
  }

  private int asr(int operand) {
    carryFlag = (operand & 0x01) != 0;
    negativeFlag = ((operand & 0x80) != 0);
    operand = (operand >> 1);
    if (negativeFlag) {  // If sign bit was set prior to shift, then retain it.
      operand |= 0x80;
    }
    negativeFlag = ((operand & 0x80) != 0);
    zeroFlag = operand == 0;
    return operand;
  }

  private int clr() {
    negativeFlag = false;
    zeroFlag = true;
    overflowFlag = false;
    carryFlag = false;
    return 0;
  }

  private int com(int operand) {
    overflowFlag = false;
    carryFlag = true;
    operand = ~operand & 0xff;
    negativeFlag = ((operand & 0x80) != 0);
    zeroFlag = operand == 0;
    return operand;
  }

  private int daa(int operand) {
    int lsn = (operand & 0x0f), msn = (operand & 0xf0);
    int temp = 0, cf = 0;
    if ((lsn > 9) || halfCarryFlag) {
      cf |= 0x06;
    }
    if ((msn > 0x80 && lsn > 0x09) || carryFlag || msn > 0x90) {
      cf |= 0x60;
    }
    temp = cf + operand;
    carryFlag = ((temp & 0x100) != 0) || carryFlag;
    operand = temp & 0xff;
    zeroFlag = (operand == 0);
    negativeFlag = ((operand & 0x80) != 0);
    return operand;
  }
  
  private int dec(int operand) {
    overflowFlag = operand == 0x80;
    operand = (operand - 1) & 0xff;
    negativeFlag = ((operand & 0x80) != 0);
    zeroFlag = operand == 0;
    return operand;
  }

  private int eor(int operand1, int operand2) {
    operand1 = (operand1 ^ operand2) & 0xff;
    overflowFlag = false;
    negativeFlag = ((operand1 & 0x80) != 0);
    zeroFlag = operand1 == 0;
    return operand1;
  }

  private void exg(int postByte) {
    int leftReg = ((postByte >> 4) & 0x0F);
    int rightReg = (postByte & 0x0F);
    int leftRegValue = 0xFFFF;
    int rightRegValue = 0xFFFF;
    switch (leftReg) {
      case 0:
        // D
        leftRegValue = getD();
        break;
      case 1:
        // X
        leftRegValue = indexRegisterX;
        break;
      case 2:
        // Y
        leftRegValue = indexRegisterY;
        break;
      case 3:
        // U
        leftRegValue = userStackPointer;
        break;
      case 4:
        // S
        leftRegValue = stackPointer;
        break;
      case 5:
        // PC
        leftRegValue = programCounter;
        break;
      case 6:
      case 7:
        // Invalid
        leftRegValue = 0xFFFF;
        break;
      case 8:
        // A
        leftRegValue = 0xFF00 | (accumulatorA & 0xFF);
        break;
      case 9:
        // B
        leftRegValue = 0xFF00 | (accumulatorB & 0xFF);
        break;
      case 10:
        // CC
        int cc = getCC();
        leftRegValue = ((cc << 8) & 0xFF00) | (cc & 0xFF);
        break;
      case 11:
        // DP
        leftRegValue = ((directPageRegister << 8) & 0xFF00) | (directPageRegister & 0xFF);
        break;
      case 12:
      case 13:
      case 14:
      case 15:
        // Invalid
        leftRegValue = 0xFFFF;
        break;
    }
    switch (rightReg) {
      case 0:
        // D
        rightRegValue = getD();
        setD((leftRegValue & 0xFFFF));
        break;
      case 1:
        // X
        rightRegValue = indexRegisterX;
        indexRegisterX = (leftRegValue & 0xFFFF);
        break;
      case 2:
        // Y
        rightRegValue = indexRegisterY;
        indexRegisterY = (leftRegValue & 0xFFFF);
        break;
      case 3:
        // U
        rightRegValue = userStackPointer;
        userStackPointer = (leftRegValue & 0xFFFF);
        break;
      case 4:
        // S
        rightRegValue = stackPointer;
        stackPointer = (leftRegValue & 0xFFFF);
        nmiArmed = true;
        break;
      case 5:
        // PC
        rightRegValue = programCounter;
        programCounter = (leftRegValue & 0xFFFF);
        break;
      case 6:
      case 7:
        // Invalid. Ignore. No effect.
        rightRegValue = 0xFFFF;
        break;
      case 8:
        // A
        rightRegValue = 0xFF00 | (accumulatorA & 0xFF);;
        accumulatorA = (leftRegValue & 0xFF);
        break;
      case 9:
        // B
        rightRegValue = 0xFF00 | (accumulatorB & 0xFF);;
        accumulatorB = (leftRegValue & 0xFF);
        break;
      case 10:
        // CC
        int cc = getCC();
        rightRegValue = ((cc << 8) & 0xFF00) | (cc & 0xFF);
        setCC(leftRegValue & 0xFF);
        break;
      case 11:
        // DP
        rightRegValue = ((directPageRegister << 8) & 0xFF00) | (directPageRegister & 0xFF);
        directPageRegister = (leftRegValue & 0xFF);
        break;
      case 12:
      case 13:
      case 14:
      case 15:
        // Invalid. Ignore. No effect.
        rightRegValue = 0xFFFF;
        break;
    }
    switch (leftReg) {
      case 0:
        // D
        setD((rightRegValue & 0xFFFF));
        break;
      case 1:
        // X
        indexRegisterX = (rightRegValue & 0xFFFF);
        break;
      case 2:
        // Y
        indexRegisterY = (rightRegValue & 0xFFFF);
        break;
      case 3:
        // U
        userStackPointer = (rightRegValue & 0xFFFF);
        break;
      case 4:
        // S
        stackPointer = (rightRegValue & 0xFFFF);
        nmiArmed = true;
        break;
      case 5:
        // PC
        programCounter = (rightRegValue & 0xFFFF);
        break;
      case 6:
      case 7:
        // Invalid. Ignore. No effect.
        break;
      case 8:
        // A
        accumulatorA = (rightRegValue & 0xFF);
        break;
      case 9:
        // B
        accumulatorB = (rightRegValue & 0xFF);
        break;
      case 10:
        // CC
        setCC(rightRegValue & 0xFF);
        break;
      case 11:
        // DP
        directPageRegister = (rightRegValue & 0xFF);
        break;
      case 12:
      case 13:
      case 14:
      case 15:
        // Invalid. Ignore. No effect.
        break;
    }
  }
  
  private void illegal() {
    System.out.println(String.format("ILLEGAL unknown instruction: %d (%02X)", instructionRegister, instructionRegister));
  }
  
  private int inc(int operand) {
    overflowFlag = operand == 0x7f;
    operand = (operand + 1) & 0xff;
    negativeFlag = ((operand & 0x80) != 0);
    zeroFlag = operand == 0;
    return operand;
  }

  private int ld8Bit(int operand) {
    overflowFlag = false;
    negativeFlag = ((operand & 0x80) != 0);
    zeroFlag = operand == 0;
    return operand;
  }

  private int ld16Bit(int operand) {
    overflowFlag = false;
    negativeFlag = ((operand & 0x8000) != 0);
    zeroFlag = operand == 0;
    return operand;
  }

  private int lsr(int operand) {
    carryFlag = (operand & 0x01) != 0;
    operand = operand >>> 1;
    negativeFlag = false;
    zeroFlag = operand == 0;
    return operand;
  }

  private int mul(int operand1, int operand2) {
    int result = ((operand1 & 0xff) * (operand2 & 0xff)) & 0xffff;
    zeroFlag = (result == 0);
    carryFlag = ((result & 0x80) != 0);
    return result;
  }
  
  private int neg(int operand) {
    overflowFlag = operand == 0x80;
    carryFlag = operand != 0;
    operand = -operand & 0xff;
    negativeFlag = ((operand & 0x80) != 0);
    zeroFlag = operand == 0;
    return operand;
  }

  private int or(int operand1, int operand2) {
    operand1 = operand1 | operand2;
    overflowFlag = false;
    negativeFlag = ((operand1 & 0x80) != 0);
    zeroFlag = operand1 == 0;
    return operand1;
  }

  private int rol(int operand) {
    overflowFlag = ((operand & 0x40) >> 6) != ((operand & 0x80) >> 7);
    boolean lastC = carryFlag;
    carryFlag = (operand & 0x80) != 0;
    operand = (operand << 1) & 0xff;
    if (lastC) {
      operand |= 0x01;
    } else {
      operand &= 0xfe;
    }
    negativeFlag = ((operand & 0x80) != 0);
    zeroFlag = operand == 0;
    return operand;
  }

  private int ror(int operand) {
    boolean lastC = carryFlag;
    carryFlag = (operand & 0x01) != 0;
    operand = (operand >>> 1) & 0xff;
    if (lastC) {
      operand |= 0x80;
    } else {
      operand &= 0x7f;
    }
    negativeFlag = ((operand & 0x80) != 0);
    zeroFlag = operand == 0;
    return operand;
  }

  private int sex(int operand) {
    negativeFlag = ((operand & 0x80) != 0);
    if (negativeFlag) {
      operand = 0xFF00 | operand;
    } else {
      operand = 0x00FF & operand;
    }
    overflowFlag = false;
    zeroFlag = (operand == 0);
    return operand;
  }
  
  private int sub8Bit(int operand1, int operand2) {
    int temp = operand1 - operand2;
    overflowFlag = ((operand1 ^ operand2 ^ temp ^ (temp >> 1)) & 0x80) != 0;
    carryFlag = (temp & 0x100) != 0;
    operand1 = temp & 0xff;
    negativeFlag = ((operand1 & 0x80) != 0);
    zeroFlag = operand1 == 0;
    return operand1;
  }
  
  private int sub16Bit(int operand1, int operand2) {
    int temp = operand1 - operand2;
    overflowFlag = ((operand1 ^ operand2 ^ temp ^ (temp >> 1)) & 0x8000) != 0;
    carryFlag = (temp & 0x10000) != 0;
    operand1 = temp & 0xffff;
    negativeFlag = ((operand1 & 0x8000) != 0);
    zeroFlag = operand1 == 0;
    return operand1;
  }

  private int sbc(int operand1, int operand2) {
    int temp;
    if (carryFlag) {
      temp = operand1 - operand2 - 1;
    } else {
      temp = operand1 - operand2;
    }
    overflowFlag = ((operand1 ^ operand2 ^ temp ^ (temp >> 1)) & 0x80) != 0;
    carryFlag = (temp & 0x100) != 0;
    operand1 = temp & 0xff;
    negativeFlag = ((operand1 & 0x80) != 0);
    zeroFlag = operand1 == 0;
    return operand1;
  }

  private void st8Bit(int operand) {
    overflowFlag = false;
    negativeFlag = ((operand & 0x80) != 0);
    zeroFlag = operand == 0;
  }

  private void st16Bit(int operand) {
    overflowFlag = false;
    negativeFlag = ((operand & 0x8000) != 0);
    zeroFlag = operand == 0;
  }

  private void tfr(int postByte) {
    int source = ((postByte >> 4) & 0x0F);
    int destination = (postByte & 0x0F);
    int sourceValue = 0xFFFF;
    switch (source) {
      case 0:
        // D
        sourceValue = getD();
        break;
      case 1:
        // X
        sourceValue = indexRegisterX;
        break;
      case 2:
        // Y
        sourceValue = indexRegisterY;
        break;
      case 3:
        // U
        sourceValue = userStackPointer;
        break;
      case 4:
        // S
        sourceValue = stackPointer;
        break;
      case 5:
        // PC
        sourceValue = programCounter;
        break;
      case 6:
      case 7:
        // Invalid
        sourceValue = 0xFFFF;
        break;
      case 8:
        // A
        sourceValue = 0xFF00 | (accumulatorA & 0xFF);
        break;
      case 9:
        // B
        sourceValue = 0xFF00 | (accumulatorB & 0xFF);
        break;
      case 10:
        // CC
        int cc = getCC();
        sourceValue = ((cc << 8) & 0xFF00) | (cc & 0xFF);
        break;
      case 11:
        // DP
        sourceValue = ((directPageRegister << 8) & 0xFF00) | (directPageRegister & 0xFF);
        break;
      case 12:
      case 13:
      case 14:
      case 15:
        // Invalid
        sourceValue = 0xFFFF;
        break;
    }
    switch (destination) {
      case 0:
        // D
        setD((sourceValue & 0xFFFF));
        break;
      case 1:
        // X
        indexRegisterX = (sourceValue & 0xFFFF);
        break;
      case 2:
        // Y
        indexRegisterY = (sourceValue & 0xFFFF);
        break;
      case 3:
        // U
        userStackPointer = (sourceValue & 0xFFFF);
        break;
      case 4:
        // S
        stackPointer = (sourceValue & 0xFFFF);
        nmiArmed = true;
        break;
      case 5:
        // PC
        programCounter = (sourceValue & 0xFFFF);
        break;
      case 6:
      case 7:
        // Invalid. Ignore. No effect.
        break;
      case 8:
        // A
        accumulatorA = (sourceValue & 0xFF);
        break;
      case 9:
        // B
        accumulatorB = (sourceValue & 0xFF);
        break;
      case 10:
        // CC
        setCC(sourceValue & 0xFF);
        break;
      case 11:
        // DP
        directPageRegister = (sourceValue & 0xFF);
        break;
      case 12:
      case 13:
      case 14:
      case 15:
        // Invalid. Ignore. No effect.
        break;
    }
  }
  
  private void tst(int operand) {
    overflowFlag = false;
    negativeFlag = ((operand & 0x80) != 0);
    zeroFlag = operand == 0;
  }

  // 5-bit 2's complement
  private int to2C5Bit(int _unsigned) {
    if (_unsigned > 0xf) {
      return _unsigned | 0xffffffe0;
    } else {
      return _unsigned;
    }
  }

  // 8-bit 2's complement
  private int to2C8Bit(int _unsigned) {
    if (_unsigned > 0x7f) {
      return _unsigned | 0xffffff00;
    } else {
      return _unsigned;
    }
  }

  // 16-bit 2's complement
  private int to2C16Bit(int _unsigned) {
    if (_unsigned > 0x7fff) {
      return _unsigned | 0xffff0000;
    } else {
      return _unsigned;
    }
  }

  public void signalIRQ(boolean state) {
    if (state) {
      interruptStatus |= S_IRQ;
    } else {
      interruptStatus &= ~S_IRQ;
    }
  }
  
  public void signalFIRQ(boolean state) {
    if (state) {
      interruptStatus |= S_FIRQ;
    } else {
      interruptStatus &= ~S_FIRQ;
    }
  }
  
  public void signalNMI(boolean state) {
    if (state) {
      interruptStatus |= S_NMI;
    } else {
      interruptStatus &= ~S_NMI;
    }
  }
  
  public boolean isIRQActive() {
    return (interruptStatus & S_IRQ) != 0;
  }
  
  public boolean isNMIActive() {
    return (interruptStatus & S_NMI) != 0;
  }
  
  public boolean isFIRQActive() {
    return (interruptStatus & S_FIRQ) != 0;
  }
  
  // Getters and Setters (mainly for unit testing, but CC and D also used in instructions)
  
  public void setCC(int cc) {
    carryFlag = (cc & C_MASK) != 0;
    overflowFlag = (cc & V_MASK) != 0;
    zeroFlag = (cc & Z_MASK) != 0;
    negativeFlag = (cc & N_MASK) != 0;
    irqDisableFlag = (cc & I_MASK) != 0;
    halfCarryFlag = (cc & H_MASK) != 0;
    firqDisableFlag = (cc & F_MASK) != 0;
    entireFlag = (cc & E_MASK) != 0;
  }

  public int getCC() {
    int cc = 0;
    if (carryFlag)
      cc |= C_MASK;
    if (overflowFlag)
      cc |= V_MASK;
    if (zeroFlag)
      cc |= Z_MASK;
    if (negativeFlag)
      cc |= N_MASK;
    if (irqDisableFlag)
      cc |= I_MASK;
    if (halfCarryFlag)
      cc |= H_MASK;
    if (firqDisableFlag)
      cc |= F_MASK;
    if (entireFlag)
      cc |= E_MASK;
    return cc;
  }

  public int getD() {
    return (accumulatorA << 8) | accumulatorB;
  }

  public void setD(int d) {
    accumulatorA = d >>> 8;
    accumulatorB = d & 0xff;
  }

  /**
   * @return the entireFlag
   */
  public boolean isEntireFlag() {
    return entireFlag;
  }

  /**
   * @param entireFlag the entireFlag to set
   */
  public void setEntireFlag(boolean entireFlag) {
    this.entireFlag = entireFlag;
  }

  /**
   * @return the firqDisableFlag
   */
  public boolean isFirqDisableFlag() {
    return firqDisableFlag;
  }

  /**
   * @param firqDisableFlag the firqDisableFlag to set
   */
  public void setFirqDisableFlag(boolean firqDisableFlag) {
    this.firqDisableFlag = firqDisableFlag;
  }

  /**
   * @return the halfCarryFlag
   */
  public boolean isHalfCarryFlag() {
    return halfCarryFlag;
  }

  /**
   * @param halfCarryFlag the halfCarryFlag to set
   */
  public void setHalfCarryFlag(boolean halfCarryFlag) {
    this.halfCarryFlag = halfCarryFlag;
  }

  /**
   * @return the irqDisableFlag
   */
  public boolean isIrqDisableFlag() {
    return irqDisableFlag;
  }

  /**
   * @param irqDisableFlag the irqDisableFlag to set
   */
  public void setIrqDisableFlag(boolean irqDisableFlag) {
    this.irqDisableFlag = irqDisableFlag;
  }

  /**
   * @return the negativeFlag
   */
  public boolean isNegativeFlag() {
    return negativeFlag;
  }

  /**
   * @param negativeFlag the negativeFlag to set
   */
  public void setNegativeFlag(boolean negativeFlag) {
    this.negativeFlag = negativeFlag;
  }

  /**
   * @return the zeroFlag
   */
  public boolean isZeroFlag() {
    return zeroFlag;
  }

  /**
   * @param zeroFlag the zeroFlag to set
   */
  public void setZeroFlag(boolean zeroFlag) {
    this.zeroFlag = zeroFlag;
  }

  /**
   * @return the overflowFlag
   */
  public boolean isOverflowFlag() {
    return overflowFlag;
  }

  /**
   * @param overflowFlag the overflowFlag to set
   */
  public void setOverflowFlag(boolean overflowFlag) {
    this.overflowFlag = overflowFlag;
  }

  /**
   * @return the carryFlag
   */
  public boolean isCarryFlag() {
    return carryFlag;
  }

  /**
   * @param carryFlag the carryFlag to set
   */
  public void setCarryFlag(boolean carryFlag) {
    this.carryFlag = carryFlag;
  }

  /**
   * @return the accumulatorA
   */
  public int getAccumulatorA() {
    return accumulatorA;
  }

  /**
   * @param accumulatorA the accumulatorA to set
   */
  public void setAccumulatorA(int accumulatorA) {
    this.accumulatorA = accumulatorA;
  }

  /**
   * @return the accumulatorB
   */
  public int getAccumulatorB() {
    return accumulatorB;
  }

  /**
   * @param accumulatorB the accumulatorB to set
   */
  public void setAccumulatorB(int accumulatorB) {
    this.accumulatorB = accumulatorB;
  }

  /**
   * @return the directPageRegister
   */
  public int getDirectPageRegister() {
    return directPageRegister;
  }

  /**
   * @param directPageRegister the directPageRegister to set
   */
  public void setDirectPageRegister(int directPageRegister) {
    this.directPageRegister = directPageRegister;
  }

  /**
   * @return the stackPointer
   */
  public int getStackPointer() {
    return stackPointer;
  }

  /**
   * @param stackPointer the stackPointer to set
   */
  public void setStackPointer(int stackPointer) {
    this.stackPointer = stackPointer;
  }

  /**
   * @return the userStackPointer
   */
  public int getUserStackPointer() {
    return userStackPointer;
  }

  /**
   * @param userStackPointer the userStackPointer to set
   */
  public void setUserStackPointer(int userStackPointer) {
    this.userStackPointer = userStackPointer;
  }

  /**
   * @return the indexRegisterX
   */
  public int getIndexRegisterX() {
    return indexRegisterX;
  }

  /**
   * @param indexRegisterX the indexRegisterX to set
   */
  public void setIndexRegisterX(int indexRegisterX) {
    this.indexRegisterX = indexRegisterX;
  }

  /**
   * @return the indexRegisterY
   */
  public int getIndexRegisterY() {
    return indexRegisterY;
  }

  /**
   * @param indexRegisterY the indexRegisterY to set
   */
  public void setIndexRegisterY(int indexRegisterY) {
    this.indexRegisterY = indexRegisterY;
  }

  /**
   * @return the programCounter
   */
  public int getProgramCounter() {
    return programCounter;
  }

  /**
   * @param programCounter the programCounter to set
   */
  public void setProgramCounter(int programCounter) {
    this.programCounter = programCounter;
    
    // If the PC is being set, then we assume its a different instruction, and
    // pointing at the opcode memory location.
    this.setInstructionRegister(NO_INSTRUCTION);
    this.instructionCycleNum = 0;
  }

  /**
   * @return the instructionRegister
   */
  public int getInstructionRegister() {
    return instructionRegister;
  }

  /**
   * @param instructionRegister the instructionRegister to set
   */
  public void setInstructionRegister(int instructionRegister) {
    this.instructionRegister = instructionRegister;
  }
}